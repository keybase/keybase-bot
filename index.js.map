{"version":3,"file":"index.js","sources":["lib/utils/formatAPIObject.js","lib/utils/keybaseExec.js","lib/utils/randomTempDir.js","lib/utils/rmdirRecursive.js","lib/utils/keybaseStatus.js","lib/utils/pingKeybaseService.js","lib/utils/whichKeybase.js","lib/utils/timeout.js","lib/service/index.js","lib/constants.js","lib/client-base/index.js","lib/chat-client/index.js","lib/wallet-client/index.js","lib/index.js"],"sourcesContent":["// @flow\nimport snakeCase from 'lodash.snakecase'\nimport camelCase from 'lodash.camelcase'\nimport kebabCase from 'lodash.kebabcase'\nimport type {API_TYPES} from '../constants'\n\n/**\n  Takes a Keybase API input JavaScript object and recursively formats it into snake_case or kebab-case instead of camelCase for the service.\n  * @ignore\n  * @param obj - The object to be formatted.\n  * @param apiType - The type of api the the input is being served to. Currently Keybase has chat, team, and wallet apis.\n  * @returns - The new, formatted object.\n  * @example\n  * const inputOptions = formatAPIObject({unreadOnly: true})\n  * console.log(inputOptions) // {unread_only: true}\n */\nexport function formatAPIObjectInput(obj: any, apiType: API_TYPES): any {\n  if (obj === null || obj === undefined || typeof obj !== 'object') {\n    return obj\n  } else if (Array.isArray(obj)) {\n    return obj.map(item => formatAPIObjectInput(item, apiType))\n  } else {\n    return Object.keys(obj).reduce((newObj, key) => {\n      // TODO: hopefully we standardize how the Keybase API handles input keys\n      let formattedKey\n      if (apiType === 'wallet') {\n        formattedKey = kebabCase(key)\n      } else {\n        formattedKey = snakeCase(key)\n      }\n\n      if (typeof obj[key] === 'object') {\n        return {...newObj, [formattedKey]: formatAPIObjectInput(obj[key], apiType)}\n      }\n      return {...newObj, [formattedKey]: obj[key]}\n    }, {})\n  }\n}\n\n/*\n * An internal blacklist of parent levels at which formatAPIObjectOutput transformations\n * shouldn't be performed. A `null` value matches everything.\n */\nconst transformsBlacklist = {\n  chat: {\n    read: [['messages', null, 'msg', 'reactions', 'reactions', null]],\n  },\n}\n\n/**\n * Context of the object formatting process.\n * @ignore\n */\nexport type FormatAPIObjectOutputContext = {|\n  apiName: string,\n  method: string,\n  parent?: any[],\n|}\n\n/*\n * Matches a context against the list of blacklisted parent levels.\n * @ignore\n * @param context - The context to match.\n * @returns - Whether the context is blacklisted from being formatted.\n */\nfunction matchBlacklist(context: ?FormatAPIObjectOutputContext): boolean {\n  if (\n    !context ||\n    !transformsBlacklist[context.apiName] ||\n    !transformsBlacklist[context.apiName][context.method]\n  ) {\n    return false\n  }\n\n  const parentLength = context.parent ? context.parent.length : 0\n\n  for (const matcher of transformsBlacklist[context.apiName][context.method]) {\n    if (matcher.length !== parentLength) {\n      continue\n    }\n\n    // Iterate over the items of the matcher\n    let mismatch = false\n    for (const [matcherIndex, desiredValue] of matcher.entries()) {\n      if (desiredValue === null) {\n        continue\n      }\n\n      if (typeof context.parent === 'object' && context.parent[matcherIndex] !== desiredValue) {\n        mismatch = true\n        break\n      }\n    }\n    if (!mismatch) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/*\n * Appends a new key to the parents array in the formatting context.\n * @ignore\n * @param context - The context to copy and modify.\n * @param key - The key to apprent to the parent array.\n * @returns - A new context.\n */\nfunction buildContext(context: ?FormatAPIObjectOutputContext, key: any): ?FormatAPIObjectOutputContext {\n  if (!context) {\n    return context\n  }\n\n  const copiedContext: FormatAPIObjectOutputContext = {...context}\n  if (!copiedContext.parent) {\n    copiedContext.parent = [key]\n  } else {\n    copiedContext.parent = copiedContext.parent.slice()\n    copiedContext.parent.push(key)\n  }\n\n  return copiedContext\n}\n\n/**\n  Takes a Keybase output object and formats it in a more digestable JavaScript style by using camelCase instead of snake_case.\n  * @ignore\n  * @param obj - The object to be formatted.\n  * @param context - An optional context with information about the called method required to perform blacklist lookups.\n  * @returns - The new, formatted object.\n  * @example\n  * const outputRes = formatAPIObject({unread_only: true})\n  * console.log(outputRes) // {unreadOnly: true}\n */\nexport function formatAPIObjectOutput(obj: any, context?: ?FormatAPIObjectOutputContext): any {\n  if (obj == null || typeof obj !== 'object') {\n    return obj\n  } else if (Array.isArray(obj)) {\n    return obj.map((item, i) => formatAPIObjectOutput(item, buildContext(context, i)))\n  } else {\n    return Object.keys(obj).reduce((newObj, key) => {\n      const formattedKey = matchBlacklist(context) ? key : camelCase(key)\n      if (typeof obj[key] === 'object') {\n        return {...newObj, [formattedKey]: formatAPIObjectOutput(obj[key], buildContext(context, key))}\n      }\n      return {...newObj, [formattedKey]: obj[key]}\n    }, {})\n  }\n}\n","// @flow\nimport {spawn} from 'child_process'\nimport readline from 'readline'\nimport path from 'path'\n\nexport type ExecOptions = {|\n  stdinBuffer?: Buffer | string,\n  onStdOut?: (line: string) => void,\n  json?: boolean,\n|}\n\nconst keybaseExec = (\n  workingDir: string,\n  homeDir?: string,\n  args: string[],\n  options: ExecOptions = {stdinBuffer: undefined, onStdOut: undefined}\n): Promise<any> => {\n  const runArgs: string[] = [...args]\n  if (homeDir) {\n    runArgs.unshift('--home', homeDir)\n  }\n  const child = spawn(path.join(workingDir, 'keybase'), runArgs)\n  const stdOutBuffer: Buffer[] = []\n  const stdErrBuffer: Buffer[] = []\n\n  if (options.stdinBuffer) {\n    child.stdin.write(options.stdinBuffer)\n  }\n  child.stdin.end()\n\n  const lineReaderStdout = readline.createInterface({input: child.stdout})\n\n  // Use readline interface to parse each line (\\n separated) when provided\n  // with onStdOut callback\n  if (options.onStdOut) {\n    lineReaderStdout.on('line', options.onStdOut)\n  } else {\n    child.stdout.on('data', chunk => {\n      stdOutBuffer.push(chunk)\n    })\n  }\n  // Capture STDERR and use as error message if needed\n  child.stderr.on('data', chunk => {\n    stdErrBuffer.push(chunk)\n  })\n\n  return new Promise((resolve, reject) => {\n    child.on('close', code => {\n      let finalStdOut: ?string = null\n      // Pass back\n      if (code) {\n        const errorMessage = Buffer.concat(stdErrBuffer).toString('utf8')\n        reject(new Error(errorMessage))\n      } else {\n        const stdout = Buffer.concat(stdOutBuffer).toString('utf8')\n\n        try {\n          finalStdOut = options.json ? JSON.parse(stdout) : stdout\n        } catch (e) {\n          reject(e)\n        }\n      }\n      resolve(finalStdOut)\n    })\n  })\n}\n\nexport default keybaseExec\n","// @flow\nimport os from 'os'\nimport path from 'path'\nimport crypto from 'crypto'\n\nfunction randomTempDir(): string {\n  const name: string = crypto.randomBytes(16).toString('hex')\n  return path.join(os.tmpdir(), `keybase_bot_${name}`)\n}\n\nexport default randomTempDir\n","// @flow\nimport fs from 'fs'\nimport path from 'path'\nimport {promisify} from 'util'\n\nasync function rmdirRecursive(dirName: string): Promise<void> {\n  const fsLstat = promisify(fs.lstat)\n  const fsUnlink = promisify(fs.unlink)\n  const fsRmdir = promisify(fs.rmdir)\n  const fsReaddir = promisify(fs.readdir)\n  const dirStat = await fsLstat(dirName)\n  if (dirStat) {\n    for (const entry of await fsReaddir(dirName)) {\n      const entryPath = path.join(dirName, entry)\n      const stat = await fsLstat(entryPath)\n      if (stat.isDirectory()) {\n        await rmdirRecursive(entryPath)\n      } else {\n        await fsUnlink(entryPath)\n      }\n    }\n    await fsRmdir(dirName)\n  }\n}\n\nexport default rmdirRecursive\n","// @flow\nimport keybaseExec from '../utils/keybaseExec'\n\n/**\n * Useful information like the username, device, home directory of your bot and\n * configuration options.\n */\nexport type BotInfo = {|\n  username: string,\n  devicename: string,\n  homeDir?: string,\n  botLite?: boolean,\n  disableTyping?: boolean,\n|}\n\n/**\n * Returns { username, devicename, homeDir } from `keybase status --json`.\n * @ignore\n * @param workingDir - the directory containing the binary, according to top level Bot\n * @param homeDir - The home directory of the service you want to fetch the status from.\n * @example\n * keybaseStatus('/my/dir').then(status => console.log(status.username))\n */\nasync function keybaseStatus(workingDir: string, homeDir?: string): Promise<BotInfo> {\n  const status = await keybaseExec(workingDir, homeDir, ['status', '--json'], {json: true})\n  if (status && status.Username && status.Device && status.Device.name) {\n    return {\n      username: status.Username,\n      devicename: status.Device.name,\n      homeDir,\n    }\n  } else {\n    throw new Error('Failed to get current username and device name.')\n  }\n}\n\nexport default keybaseStatus\n","// @flow\nimport keybaseExec from '../utils/keybaseExec'\n\n/**\n * Checks whether the keybase service is running by calling `keybase status --json`.\n * @ignore\n * @param workingDir - the directory containing the binary, according to top level Bot\n * @param homeDir - The home directory of the service you want to fetch the status from.\n * @example\n * pingKeybaseService('/my/dir').then(status => console.log(\"service running\", status))\n */\nasync function pingKeybaseService(workingDir: string, homeDir?: string): Promise<boolean> {\n  // TODO: use a faster technique when core releases one\n  try {\n    await keybaseExec(workingDir, homeDir, ['--no-auto-fork', 'status', '--json'], {json: true})\n    return true\n  } catch (err) {\n    return false\n  }\n}\n\nexport default pingKeybaseService\n","// @flow\nimport {exec} from 'child_process'\nimport {promisify} from 'util'\n\nconst aExec = promisify(exec)\n\n/**\n * Returns the full path to the keybase binary or throws an error\n * @ignore\n * @example\n * whichKeybase().then((path) => console.log(path))\n */\nasync function whichKeybase(): Promise<string> {\n  const {stdout} = await aExec('which keybase')\n  if (!stdout || !stdout.trim().length) {\n    throw new Error('Could not find keybase binary')\n  }\n  const res = stdout.trim()\n  return res\n}\n\nexport default whichKeybase\n","// @flow\nfunction timeout(time: number): Promise<void> {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve()\n    }, time)\n  })\n}\n\nexport default timeout\n","// @flow\nimport {keybaseExec, keybaseStatus, pingKeybaseService, timeout} from '../utils'\nimport {spawn} from 'child_process'\nimport type {BotInfo} from '../utils/keybaseStatus'\nimport type {InitOptions} from '../utils/options'\nimport path from 'path'\n\nclass Service {\n  initialized: false | 'paperkey' | 'runningService'\n  running: boolean\n  username: void | string\n  devicename: void | string\n  homeDir: void | string\n  verbose: boolean\n  botLite: boolean\n  disableTyping: boolean\n  serviceLogFile: void | string\n  workingDir: string\n  constructor(workingDir: string) {\n    this.workingDir = workingDir\n    this.initialized = false\n    this.verbose = false\n    this.botLite = true\n    this.disableTyping = true\n  }\n\n  async init(username: string, paperkey: string, options?: InitOptions): Promise<void> {\n    if (!username || typeof username !== 'string') {\n      throw new Error(`Please provide a username to initialize the bot. Got: ${JSON.stringify(username)}`)\n    }\n    if (!paperkey || typeof paperkey !== 'string') {\n      // Don't want to accidentally print the paperkey to STDERR.\n      throw new Error(`Please provide a paperkey to initialize the bot.`)\n    }\n    if (this.initialized) {\n      throw new Error('Cannot initialize an already initialized bot.')\n    }\n\n    this.homeDir = this.workingDir\n    this.serviceLogFile = path.join(this.homeDir, 'Library', 'Logs', 'keybase.service.log')\n    this.botLite = options ? Boolean(typeof options.botLite !== 'boolean' || options.botLite) : true\n    this.disableTyping = options\n      ? Boolean(typeof options.disableTyping !== 'boolean' || options.disableTyping)\n      : true\n    // Unlike with clients we don't need to store the service, since it shuts down with ctrl stop\n    try {\n      await this.startupService()\n      await keybaseExec(this.workingDir, this.homeDir, ['oneshot', '--username', username], {\n        stdinBuffer: paperkey,\n      })\n\n      // Set the typing notification settings for the bot\n      await keybaseExec(this.workingDir, this.homeDir, [\n        'chat',\n        'notification-settings',\n        'disable-typing',\n        this.disableTyping.toString(),\n      ])\n\n      const currentInfo = await keybaseStatus(this.workingDir, this.homeDir)\n\n      if (currentInfo && currentInfo.username && currentInfo.devicename) {\n        this.initialized = 'paperkey'\n        this.username = currentInfo.username\n        this.devicename = currentInfo.devicename\n        this.verbose = options ? Boolean(options.verbose) : false\n      }\n      if (this.username !== username) {\n        throw new Error('Failed to initialize service.')\n      }\n    } catch (err) {\n      await this._killCustomService()\n      throw err\n    }\n  }\n\n  async initFromRunningService(homeDir?: string, options?: InitOptions) {\n    if (this.initialized) {\n      throw new Error('Cannot initialize an already initialized bot.')\n    }\n    this.homeDir = homeDir\n\n    const currentInfo = await keybaseStatus(this.workingDir, this.homeDir)\n    if (currentInfo && currentInfo.username && currentInfo.devicename) {\n      this.initialized = 'runningService'\n      this.username = currentInfo.username\n      this.devicename = currentInfo.devicename\n      this.verbose = options ? Boolean(options.verbose) : false\n    }\n  }\n\n  async _killCustomService(): Promise<void> {\n    // these 2 commands might be unnecessary; since the service was `spawn`ed not detached\n    // they will also shutdown via SIGINT. We don't want to make service detached because it'd be nice for\n    // them to auto-shutdown if the user kills the process\n    try {\n      await keybaseExec(this.workingDir, this.homeDir, ['logout'])\n    } catch (e) {}\n    try {\n      await keybaseExec(this.workingDir, this.homeDir, ['ctl', 'stop', '--shutdown'])\n    } catch (e) {}\n    // wait until the process quits by watching the running property\n    let i = 0\n    while (true) {\n      await timeout(100)\n\n      if (!this.running) {\n        break\n      }\n\n      if (++i >= 100) {\n        throw new Error(`The service didn't finish shutting down in time (${this.workingDir})`)\n      }\n    }\n  }\n\n  async deinit(): Promise<void> {\n    if (!this.initialized) {\n      throw new Error('Cannot deinitialize an uninitialized bot.')\n    }\n    // If we init the bot using paperkey credentials, then we want to stop the service and remove our generated directory.\n    if (this.initialized === 'paperkey') {\n      await this._killCustomService()\n    }\n    this.initialized = false\n  }\n\n  myInfo(): ?BotInfo {\n    if (this.username && this.devicename) {\n      return {\n        username: this.username,\n        devicename: this.devicename,\n        homeDir: this.homeDir ? this.homeDir : undefined,\n        botLite: this.botLite,\n        disableTyping: this.disableTyping,\n      }\n    }\n    return null\n  }\n\n  /**\n   *\n   * @ignore\n   * This is a bit different from normal keybaseExecs and is unique to the service\n   * starting up\n   * @example\n   * service.startupService()\n   */\n  async startupService(): Promise<void> {\n    const args = ['service']\n    if (this.homeDir) {\n      args.unshift('--home', this.homeDir)\n    }\n    if (this.serviceLogFile) {\n      args.unshift('-d', '--log-file', this.serviceLogFile)\n    }\n    if (this.botLite) {\n      args.unshift('--enable-bot-lite-mode')\n    }\n    const child = spawn('keybase', args, {env: process.env})\n\n    // keep track of the subprocess' state\n    this.running = true\n    child.on('exit', code => {\n      this.running = false\n    })\n\n    return new Promise(async (resolve, reject) => {\n      child.on('close', code => {\n        // any code here including 0 is bad here, if it happens before resolve\n        //, since this service should stay running\n        reject(new Error(`keybase service exited with code ${code} (${this.workingDir})`))\n      })\n\n      // Wait for the service to start up - give it 10s.\n      let i = 0\n      while (!(await pingKeybaseService(this.workingDir, this.homeDir))) {\n        await timeout(100)\n        if (++i >= 100) {\n          throw new Error(\"Couldn't start up service fast enough\")\n        }\n      }\n      resolve()\n    })\n  }\n}\n\nexport default Service\n","// @flow\nexport const API_VERSIONS = {\n  chat: 1,\n  team: 1,\n  wallet: 1,\n}\n\nexport type API_TYPES = 'chat' | 'team' | 'wallet'\n","// @flow\nimport type {ChildProcess} from 'child_process'\nimport {formatAPIObjectInput, formatAPIObjectOutput, keybaseExec, keybaseStatus} from '../utils'\nimport type {InitOptions} from '../utils/options'\nimport {API_VERSIONS, type API_TYPES} from '../constants'\nimport path from 'path'\n\nexport type ApiCommandArg = {|apiName: API_TYPES, method: string, options?: Object|}\n\n/**\n * A Client base.\n * @ignore\n */\nclass ClientBase {\n  initialized: boolean\n  username: void | string\n  devicename: void | string\n  homeDir: void | string\n  verbose: boolean\n  spawnedProcesses: ChildProcess[]\n  _workingDir: string\n\n  constructor(workingDir: string) {\n    this._workingDir = workingDir\n    this.initialized = false\n    this.verbose = false\n    this.spawnedProcesses = []\n  }\n\n  async _init(homeDir: void | string, options?: InitOptions): Promise<void> {\n    const initBotInfo = await keybaseStatus(this._workingDir, homeDir)\n    this.homeDir = homeDir\n    this.username = initBotInfo.username\n    this.devicename = initBotInfo.devicename\n    this.initialized = true\n  }\n\n  async _deinit(): Promise<void> {\n    for (const child of this.spawnedProcesses) {\n      child.kill()\n    }\n  }\n\n  async _runApiCommand(arg: ApiCommandArg): Promise<any> {\n    const options = arg.options ? formatAPIObjectInput(arg.options, arg.apiName) : undefined\n    const input = {\n      method: arg.method,\n      params: {\n        version: API_VERSIONS[arg.apiName],\n        options,\n      },\n    }\n    const inputString = JSON.stringify(input)\n    const size = inputString.length\n    const output = await keybaseExec(this._workingDir, this.homeDir, [arg.apiName, 'api'], {\n      stdinBuffer: Buffer.alloc(size, inputString, 'utf8'),\n      json: true,\n    })\n    if (output.hasOwnProperty('error')) {\n      throw new Error(output.error.message)\n    }\n    const res = formatAPIObjectOutput(output.result, {\n      apiName: arg.apiName,\n      method: arg.method,\n    })\n    return res\n  }\n\n  async _guardInitialized(): Promise<void> {\n    if (!this.initialized) {\n      throw new Error('The client is not yet initialized.')\n    }\n  }\n  _pathToKeybaseBinary(): string {\n    return path.join(this._workingDir, 'keybase')\n  }\n}\n\nexport default ClientBase\n","// @flow\nimport {spawn} from 'child_process'\nimport readline from 'readline'\nimport ClientBase from '../client-base'\nimport {formatAPIObjectOutput} from '../utils'\nimport type {\n  ChatConversation,\n  ChatChannel,\n  ChatMessage,\n  MessageSummary,\n  ListenOptions,\n  ReadResult,\n  SendResult,\n  ChatListOptions,\n  ChatListChannelsOptions,\n  ChatReadOptions,\n  ChatSendOptions,\n  ChatAttachOptions,\n  ChatDownloadOptions,\n  ChatDeleteOptions,\n  ChatReactOptions,\n  MessageNotification,\n} from './types'\n\n/** A function to call when a message is received. */\nexport type OnMessage = (message: MessageSummary) => void | Promise<void>\n/** A function to call when an error occurs. */\nexport type OnError = (error: Error) => void | Promise<void>\n\n/** The chat module of your Keybase bot. For more info about the API this module uses, you may want to check out `keybase chat api`. */\nclass Chat extends ClientBase {\n  /**\n   * Lists your chats, with info on which ones have unread messages.\n   * @memberof Chat\n   * @param options - An object of options that can be passed to the method.\n   * @returns - An array of chat conversations. If there are no conversations, the array is empty.\n   * @example\n   * bot.chat.list({unreadOnly: true}).then(chatConversations => console.log(chatConversations))\n   */\n  async list(options?: ChatListOptions): Promise<ChatConversation[]> {\n    await this._guardInitialized()\n    const res = await this._runApiCommand({apiName: 'chat', method: 'list', options})\n    if (!res) {\n      throw new Error('Keybase chat list returned nothing.')\n    }\n    return res.conversations || []\n  }\n\n  /**\n   * Lists conversation channels in a team\n   * @memberof Chat\n   * @param name - Name of the team\n   * @param options - An object of options that can be passed to the method.\n   * @returns - An array of chat conversations. If there are no conversations, the array is empty.\n   * @example\n   * bot.chat.listChannels('team_name').then(chatConversations => console.log(chatConversations))\n   */\n  async listChannels(name: string, options?: ChatListChannelsOptions): Promise<ChatConversation[]> {\n    await this._guardInitialized()\n    const optionsWithDefaults = {\n      ...options,\n      name,\n      membersType: options && options.membersType ? options.membersType : 'team',\n    }\n    const res = await this._runApiCommand({\n      apiName: 'chat',\n      method: 'listconvsonname',\n      options: optionsWithDefaults,\n    })\n    if (!res) {\n      throw new Error('Keybase chat list convs on name returned nothing.')\n    }\n    return res.conversations || []\n  }\n\n  /**\n   * Reads the messages in a channel. You can read with or without marking as read.\n   * @memberof Chat\n   * @param channel - The chat channel to read messages in.\n   * @param options - An object of options that can be passed to the method.\n   * @returns - A summary of data about a message, including who send it, when, the content of the message, etc. If there are no messages in your channel, then an error is thrown.\n   * @example\n   * alice.chat.read(channel).then(messages => console.log(messages))\n   */\n  async read(channel: ChatChannel, options?: ChatReadOptions): Promise<ReadResult> {\n    await this._guardInitialized()\n    const optionsWithDefaults = {\n      ...options,\n      channel,\n      peek: options && options.peek ? options.peek : false,\n      unreadOnly: options && options.unreadOnly !== undefined ? options.unreadOnly : false,\n    }\n    const res = await this._runApiCommand({apiName: 'chat', method: 'read', options: optionsWithDefaults})\n    if (!res) {\n      throw new Error('Keybase chat read returned nothing.')\n    }\n    // Pagination gets passed as-is, while the messages get cleaned up\n    return {\n      pagination: res.pagination,\n      messages: res.messages.map(message => message.msg),\n    }\n  }\n\n  /**\n   * Joins a team conversation.\n   * @param channel - The team chat channel to join.\n   * @example\n   * bot.chat.listConvsOnName('team_name').then(async teamConversations => {\n   *  for (const conversation of teamConversations) {\n   *    if (conversation.memberStatus !== 'active') {\n   *      await bot.chat.join(conversation.channel)\n   *      console.log('Joined team channel', conversation.channel)\n   *    }\n   *  }\n   * })\n   */\n  async joinChannel(channel: ChatChannel): Promise<void> {\n    await this._guardInitialized()\n    const res = await this._runApiCommand({\n      apiName: 'chat',\n      method: 'join',\n      options: {\n        channel,\n      },\n    })\n    if (!res) {\n      throw new Error('Keybase chat join returned nothing')\n    }\n  }\n\n  /**\n   * Leaves a team conversation.\n   * @param channel - The team chat channel to leave.\n   * @example\n   * bot.chat.listConvsOnName('team_name').then(async teamConversations => {\n   *  for (const conversation of teamConversations) {\n   *    if (conversation.memberStatus === 'active') {\n   *      await bot.chat.leave(conversation.channel)\n   *      console.log('Left team channel', conversation.channel)\n   *    }\n   *  }\n   * })\n   */\n  async leaveChannel(channel: ChatChannel): Promise<void> {\n    await this._guardInitialized()\n    const res = await this._runApiCommand({\n      apiName: 'chat',\n      method: 'leave',\n      options: {\n        channel,\n      },\n    })\n    if (!res) {\n      throw new Error('Keybase chat leave returned nothing')\n    }\n  }\n\n  /**\n   * Send a message to a certain channel.\n   * @memberof Chat\n   * @param channel - The chat channel to send the message in.\n   * @param message - The chat message to send.\n   * @param options - An object of options that can be passed to the method.\n   * @example\n   * const channel = {name: 'kbot,' + bot.myInfo().username, public: false, topicType: 'chat'}\n   * const message = {body: 'Hello kbot!'}\n   * bot.chat.send(channel, message).then(() => console.log('message sent!'))\n   */\n  async send(channel: ChatChannel, message: ChatMessage, options?: ChatSendOptions): Promise<SendResult> {\n    await this._guardInitialized()\n    const args = {\n      ...options,\n      channel,\n      message,\n    }\n    const res = await this._runApiCommand({\n      apiName: 'chat',\n      method: 'send',\n      options: args,\n    })\n    if (!res) {\n      throw new Error('Keybase chat send returned nothing')\n    }\n\n    return {id: res.id}\n  }\n\n  /**\n   * Creates a new blank conversation.\n   * @memberof Chat\n   * @param channel - The chat channel to create.\n   * @example\n   * bot.chat.createChannel(channel).then(() => console.log('conversation created'))\n   */\n  async createChannel(channel: ChatChannel): Promise<void> {\n    await this._guardInitialized()\n    const args = {\n      channel,\n    }\n    const res = await this._runApiCommand({\n      apiName: 'chat',\n      method: 'newconv',\n      options: args,\n    })\n    if (!res) {\n      throw new Error('Keybase chat newconv returned nothing')\n    }\n  }\n\n  /**\n   * Send a file to a channel.\n   * @memberof Chat\n   * @param channel - The chat channel to send the message in.\n   * @param filename - The absolute path of the file to send.\n   * @param options - An object of options that can be passed to the method.\n   * @example\n   * bot.chat.attach(channel, '/Users/nathan/my_picture.png').then(() => console.log('Sent a picture!'))\n   */\n  async attach(channel: ChatChannel, filename: string, options: ChatAttachOptions): Promise<SendResult> {\n    await this._guardInitialized()\n    const args = {...options, channel, filename}\n    const res = await this._runApiCommand({apiName: 'chat', method: 'attach', options: args})\n    if (!res) {\n      throw new Error('Keybase chat attach returned nothing')\n    }\n\n    return {id: res.id}\n  }\n\n  /**\n   * Download a file send via Keybase chat.\n   * @memberof Chat\n   * @param channel - The chat channel that the desired attacment to download is in.\n   * @param messageId - The message id of the attached file.\n   * @param output - The absolute path of where the file should be downloaded to.\n   * @param options - An object of options that can be passed to the method\n   * @example\n   * bot.chat.download(channel, 325, '/Users/nathan/Downloads/file.png')\n   */\n  async download(channel: ChatChannel, messageId: number, output: string, options: ChatDownloadOptions) {\n    await this._guardInitialized()\n    const args = {...options, channel, messageId, output}\n    const res = await this._runApiCommand({apiName: 'chat', method: 'download', options: args})\n    if (!res) {\n      throw new Error('Keybase chat download returned nothing')\n    }\n  }\n\n  /**\n   * Reacts to a given message in a channel. Messages have messageId's associated with\n   * them, which you can learn in `bot.chat.read`.\n   * @memberof Chat\n   * @param channel - The chat channel to send the message in.\n   * @param messageId - The id of the message to react to.\n   * @param reaction - The reaction emoji, in colon form.\n   * @param options - An object of options that can be passed to the method.\n   * @example\n   * bot.chat.react(channel, 314, ':+1:').then(() => console.log('Thumbs up!'))\n   */\n  async react(\n    channel: ChatChannel,\n    messageId: number,\n    reaction: string,\n    options?: ChatReactOptions\n  ): Promise<SendResult> {\n    await this._guardInitialized()\n    const args = {\n      ...options,\n      channel,\n      messageId,\n      message: {body: reaction},\n    }\n    const res = await this._runApiCommand({apiName: 'chat', method: 'reaction', options: args})\n    if (!res) {\n      throw new Error('Keybase chat react returned nothing.')\n    }\n\n    return {id: res.id}\n  }\n\n  /**\n   * Deletes a message in a channel. Messages have messageId's associated with\n   * them, which you can learn in `bot.chat.read`. Known bug: the GUI has a cache,\n   * and deleting from the CLI may not become apparent immediately.\n   * @memberof Chat\n   * @param channel - The chat channel to send the message in.\n   * @param messageId - The id of the message to delete.\n   * @param options - An object of options that can be passed to the method.\n   * @example\n   * bot.chat.delete(channel, 314).then(() => console.log('message deleted!'))\n   */\n  async delete(channel: ChatChannel, messageId: number, options?: ChatDeleteOptions): Promise<void> {\n    await this._guardInitialized()\n    const args = {\n      ...options,\n      channel,\n      messageId,\n    }\n    const res = await this._runApiCommand({apiName: 'chat', method: 'delete', options: args})\n    if (!res) {\n      throw new Error('Keybase chat delete returned nothing.')\n    }\n  }\n\n  /**\n   * Listens for new chat messages on a specified channel. The `onMessage` function is called for every message your bot receives. This is pretty similar to `watchAllChannelsForNewMessages`, except it specifically checks one channel. Note that it receives messages your own bot posts, but from other devices. You can filter out your own messages by looking at a message's sender object.\n   * Hides exploding messages by default.\n   * @memberof Chat\n   * @param channel - The chat channel to watch.\n   * @param onMessage - A callback that is triggered on every message your bot receives.\n   * @param onError - A callback that is triggered on any error that occurs while the method is executing.\n   * @param options - Options for the listen method.\n   * @example\n   * // Reply to all messages between you and `kbot` with 'thanks!'\n   * const channel = {name: 'kbot,' + bot.myInfo().username, public: false, topicType: 'chat'}\n   * const onMessage = message => {\n   *   const channel = message.channel\n   *   bot.chat.send(channel, {body: 'thanks!!!'})\n   * }\n   * bot.chat.watchChannelForNewMessages(channel, onMessage)\n   */\n  async watchChannelForNewMessages(\n    channel: ChatChannel,\n    onMessage: OnMessage,\n    onError?: OnError,\n    options?: ListenOptions\n  ): Promise<void> {\n    await this._guardInitialized()\n    this._chatListen(onMessage, onError, channel, options)\n  }\n\n  /**\n   * This function will put your bot into full-read mode, where it reads\n   * everything it can and every new message it finds it will pass to you, so\n   * you can do what you want with it. For example, if you want to write a\n   * Keybase bot that talks shit at anyone who dares approach it, this is the\n   * function to use. Note that it receives messages your own bot posts, but from other devices.\n   * You can filter out your own messages by looking at a message's sender object.\n   * Hides exploding messages by default.\n   * @memberof Chat\n   * @param onMessage - A callback that is triggered on every message your bot receives.\n   * @param onError - A callback that is triggered on any error that occurs while the method is executing.\n   * @param options - Options for the listen method.\n   * @example\n   * // Reply to incoming traffic on all channels with 'thanks!'\n   * const onMessage = message => {\n   *   const channel = message.channel\n   *   bot.chat.send(channel, {body: 'thanks!!!'})\n   * }\n   * bot.chat.watchAllChannelsForNewMessages(onMessage)\n   *\n   */\n  async watchAllChannelsForNewMessages(\n    onMessage: OnMessage,\n    onError?: OnError,\n    options?: ListenOptions\n  ): Promise<void> {\n    await this._guardInitialized()\n    this._chatListen(onMessage, onError, undefined, options)\n  }\n\n  /**\n   *\n   * @memberof Chat\n   * @ignore\n   * @param username - the user watching this chat\n   * @param name - their name of the chat, which may or may not include them\n   * @example\n   * this._normalizeNonTeamName('max', 'strib,chris') // chris,max,strib\n   */\n\n  _normalizeNonTeamName(name: string): string {\n    const s = new Set(name.toLowerCase().split(','))\n    if (this.username) {\n      s.add(this.username.toLowerCase())\n    }\n    return Array.from(s)\n      .sort()\n      .join(',')\n  }\n\n  /**\n   *\n   * @memberof Chat\n   * @ignore\n   * @param userWatching - this is a channel the user has requested to watch, which may be incomplete\n   * @param whatCameBack - a message has come back on a channel and we want to see if it matches\n   * @example\n   * this._channelMatch(channelUserWants, channelThatGotAMessage)\n   */\n  _channelMatch(userWatching: ChatChannel, whatCameBack: any): boolean {\n    const wantsPublic = userWatching.public === undefined ? false : userWatching.public\n    const wantsTopicType = userWatching.topicType === undefined ? 'chat' : userWatching.topicType\n    // if we have a team, the names much match exactly\n    if (whatCameBack.membersType === 'team') {\n      if (whatCameBack.name !== userWatching.name) {\n        return false\n      }\n    }\n    // with imp team, user could ask in any order, and they also might be forgetting themselves\n    else {\n      const nameWanted = this._normalizeNonTeamName(userWatching.name)\n      const nameGotten = this._normalizeNonTeamName(whatCameBack.name)\n      if (nameWanted !== nameGotten) {\n        return false\n      }\n    }\n    return (\n      whatCameBack.topicName === userWatching.topicName &&\n      whatCameBack.public === wantsPublic &&\n      whatCameBack.topicType === wantsTopicType\n    )\n  }\n\n  /**\n   * Spawns the chat listen process and handles the calling of onMessage, onError, and filtering for a specific channel.\n   * @memberof Chat\n   * @ignore\n   * @param onMessage - A callback that is triggered on every message your bot receives.\n   * @param onError - A callback that is triggered on any error that occurs while the method is executing.\n   * @param channel - The chat channel to watch.\n   * @param options - Options for the listen method.\n   * @example\n   * this._chatListen(onMessage, onError)\n   */\n  _chatListen(onMessage: OnMessage, onError?: OnError, channel?: ChatChannel, options?: ListenOptions): void {\n    const args = ['chat', 'api-listen']\n    if (this.homeDir) {\n      args.unshift('--home', this.homeDir)\n    }\n    if (!options || (options && options.hideExploding !== false)) {\n      args.push('--hide-exploding')\n    }\n    const child = spawn(this._pathToKeybaseBinary(), args)\n    this.spawnedProcesses.push(child)\n\n    const lineReaderStdout = readline.createInterface({input: child.stdout})\n    const onLine = (line: string) => {\n      try {\n        const messageObject: MessageNotification = formatAPIObjectOutput(JSON.parse(line))\n        if (messageObject.hasOwnProperty('error')) {\n          throw new Error(messageObject.error)\n        } else if (\n          // fire onMessage if it was from a different sender or at least a different device\n          // from this sender. Bots can filter out their own messages from other devices.\n          (!channel || this._channelMatch(channel, messageObject.msg.channel)) &&\n          this.username &&\n          this.devicename &&\n          (messageObject.msg.sender.username !== this.username.toLowerCase() ||\n            messageObject.msg.sender.deviceName !== this.devicename)\n        ) {\n          onMessage(messageObject.msg)\n        }\n      } catch (error) {\n        if (onError) {\n          onError(error)\n        }\n      }\n    }\n    lineReaderStdout.on('line', onLine)\n  }\n}\n\nexport default Chat\n","// @flow\nimport ClientBase from '../client-base'\nimport type {Account, Transaction, PaymentBatchItem, BatchResult} from './types'\n\n/** The wallet module of your Keybase bot. For more info about the API this module uses, you may want to check out `keybase wallet api`. */\nclass Wallet extends ClientBase {\n  /**\n   * Provides a list of all accounts owned by the current Keybase user.\n   * @memberof Wallet\n   * @returns - An array of accounts. If there are no accounts, the array is empty.\n   * @example\n   * bot.wallet.balances().then(accounts => console.log(accounts))\n   */\n  async balances(): Promise<Account[]> {\n    await this._guardInitialized()\n    const res = await this._runApiCommand({apiName: 'wallet', method: 'balances'})\n    if (!res) {\n      throw new Error('Keybase wallet balanaces returned nothing.')\n    }\n    return res || []\n  }\n\n  /**\n   * Provides a list of all transactions in a single account.\n   * @memberof Wallet\n   * @param accountId - The id of an account owned by a Keybase user.\n   * @returns - An array of transactions related to the account.\n   * @example\n   * bot.wallet.history('GDUKZH6Q3U5WQD4PDGZXYLJE3P76BDRDWPSALN4OUFEESI2QL5UZHCK').then(transactions => console.log(transactions))\n   */\n  async history(accountId: string): Promise<Transaction[]> {\n    await this._guardInitialized()\n    const options = {\n      accountId,\n    }\n    const res = await this._runApiCommand({apiName: 'wallet', method: 'history', options: options})\n    if (!res) {\n      throw new Error('Keybase wallet history returned nothing.')\n    }\n    // Removes a single object with property `payment`\n    const cleanedRes = res.map(payment => payment.payment)\n    return cleanedRes\n  }\n\n  /**\n   * Get details about a particular transaction\n   * @memberof Wallet\n   * @param transactionId - The id of the transaction you would like details about.\n   * @returns - An object of details about the transaction specified.\n   * @example\n   * bot.wallet.details('e5334601b9dc2a24e031ffeec2fce37bb6a8b4b51fc711d16dec04d3e64976c4').then(details => console.log(details))\n   */\n  async details(transactionId: string): Promise<Transaction> {\n    await this._guardInitialized()\n    const options = {txid: transactionId}\n    const res = await this._runApiCommand({apiName: 'wallet', method: 'details', options: options})\n    if (!res) {\n      throw new Error('Keybase wallet details returned nothing.')\n    }\n    return res\n  }\n\n  /**\n   * Lookup the primary Stellar account ID of a Keybase user.\n   * @memberof Wallet\n   * @param name - The name of the user you want to lookup. This can be either a Keybase username or a username of another account that is supported by Keybase if it is followed by an '@<service>'.\n   * @returns - An object containing the account ID and Keybase username of the found user.\n   * @example\n   * const lookup1 = bot.wallet.lookup('patrick')\n   * // 'patrick' on Keybase is 'patrickxb' on twitter\n   * const lookup2 = bot.wallet.lookup('patrcikxb@twitter')\n   * // Using Lodash's `isEqual` since objects with same values aren't equal in JavaScript\n   * _.isEqual(lookup1, lookup2) // => true\n   */\n  async lookup(name: string): Promise<{|accountID: string, username: string|}> {\n    await this._guardInitialized()\n    const options = {name}\n    const res = await this._runApiCommand({apiName: 'wallet', method: 'lookup', options})\n    if (!res) {\n      throw new Error('Keybase wallet lookup returned nothing.')\n    }\n    return res\n  }\n\n  /**\n   * Send lumens (XLM) via Keybase with your bot!\n   * @memberof Wallet\n   * @param recipient - Who you're sending your money to. This can be a Keybase user, stellar address, or a username of another account that is supported by Keybase if it is followed by an '@<service>'.\n   * @param amount - The amount of XLM to send.\n   * @param [currency] - Adds a currency value to the amount specified. For example, adding 'USD' would send\n   * @param [message] - The message for your payment\n   * @returns - The trasaction object of the transaction.\n   * @example\n   * bot.wallet.send('nathunsmitty', '3.50') // Send 3.50 XLM to Keybase user `nathunsmitty`\n   * bot.wallet.send('nathunsmitty@github', '3.50') // Send 3.50 XLM to GitHub user `nathunsmitty`\n   * bot.wallet.send('nathunsmitty', '3.50', 'USD') // Send $3.50 worth of lumens to Keybase user `nathunsmitty`\n   * bot.wallet.send('nathunsmitty', '3.50', 'USD', 'Shut up and take my money!') // Send $3.50 worth of lumens to Keybase user `nathunsmitty` with a memo\n   */\n  async send(recipient: string, amount: string, currency?: string, message?: string): Promise<Transaction> {\n    await this._guardInitialized()\n    const options = {recipient, amount, currency, message}\n    const res = await this._runApiCommand({apiName: 'wallet', method: 'send', options})\n    if (!res) {\n      throw new Error('Keybase wallet send returned nothing.')\n    }\n    return res\n  }\n\n  /**\n   * Send lumens (XLM) via Keybase to more than one user at once. As opposed to the normal bot.wallet.send\n   * command, this can get multiple transactions into the same 5-second Stellar ledger.\n   * @memberof Wallet\n   * @param batchId - example, if sending a bunch of batches for an airdrop, you could pass them all `airdrop2025`.\n   * @param payments - an array of objects containing recipients and XLM of the form {\"recipient\": \"someusername\", \"amount\": \"1.234\", \"message\", \"hi there\"}\n   * @returns - an object\n   * @example\n   * bot.wallet.batch(\"airdrop2040\",[{\"recipient\":\"a1\",\"amount\": \"1.414\", \"message\": \"hi a1, yes 1\"},{\"recipient\": \"a2\", \"amount\": \"3.14159\", \"message\": \"hi a2, yes 2\"},}])\n   */\n\n  async batch(batchId: string, payments: PaymentBatchItem[]): Promise<BatchResult> {\n    await this._guardInitialized()\n    const options = {batchId, payments}\n    const res = await this._runApiCommand({apiName: 'wallet', method: 'batch', options})\n    if (!res) {\n      throw new Error('Keybase wallet batch returned nothing.')\n    }\n    return res\n  }\n\n  /**\n   * If you send XLM to a Keybase user who has not established a wallet, you can cancel the payment before the recipient claims it and the XLM will be returned to your account.\n   * @memberof Wallet\n   * @param transactionId - The id of the transaction to cancel.\n   * @example\n   * bot.wallet.cancel('e5334601b9dc2a24e031ffeec2fce37bb6a8b4b51fc711d16dec04d3e64976c4').then(() => console.log('Transaction successfully canceled!'))\n   */\n  async cancel(transactionId: string): Promise<void> {\n    await this._guardInitialized()\n    const options = {txid: transactionId}\n    const res = await this._runApiCommand({apiName: 'wallet', method: 'cancel', options})\n    if (!res) {\n      throw new Error('Keybase wallet cancel returned nothing.')\n    }\n  }\n}\n\nexport default Wallet\n","// @flow\nimport Service from './service'\nimport ChatClient from './chat-client'\nimport WalletClient from './wallet-client'\nimport type {BotInfo} from './utils/keybaseStatus'\nimport mkdirp from 'mkdirp'\nimport {randomTempDir, whichKeybase, rmdirRecursive} from './utils'\nimport {promisify} from 'util'\nimport {copyFile} from 'fs'\nimport path from 'path'\nimport type {InitOptions} from './utils/options'\n\n/** A Keybase bot. */\nclass Bot {\n  chat: ChatClient\n  wallet: WalletClient\n  _workingDir: string // where KB binary copied, and homeDir (if not existing svc)\n  _service: Service\n\n  /**\n   * Create a bot. Note you can't do much too exciting with your bot after you instantiate it; you have to initialize it first.\n   * @memberof Bot\n   * @example\n   * const bot = new Bot()\n   */\n  constructor() {\n    this._workingDir = randomTempDir()\n    this._service = new Service(this._workingDir)\n    this.chat = new ChatClient(this._workingDir)\n    this.wallet = new WalletClient(this._workingDir)\n  }\n\n  /**\n   * Initialize your bot by starting an instance of the Keybase service and logging in using oneshot mode.\n   * @memberof Bot\n   * @param username - The username of your bot's Keybase account.\n   * @param paperkey - The paperkey of your bot's Keybase account.\n   * @param options - The initialization options for your bot.\n   * @example\n   * bot.init('username', 'paperkey')\n   */\n  async init(username: string, paperkey: string, options?: InitOptions): Promise<void> {\n    await this._prepWorkingDir()\n    await this._service.init(username, paperkey, options)\n    await this._initSubBots(options)\n  }\n\n  /**\n   * Initialize your bot by using an existing running service with a logged in user.\n   * @memberof Bot\n   * @param homeDir - The home directory of this currently running service. Leave blank to use the default homeDir for your system.\n   * @param options - The initialization options for your bot.\n   * @example\n   * bot.initFromRunningService()\n   */\n  async initFromRunningService(homeDir?: string, options?: InitOptions): Promise<void> {\n    await this._prepWorkingDir()\n    await this._service.initFromRunningService(homeDir, options)\n    await this._initSubBots(options)\n  }\n\n  /**\n   * Get info about your bot!\n   * @memberof Bot\n   * @returns â€“ Useful information like the username, device, and home directory of your bot. If your bot isn't initialized, you'll get `null`.\n   * @example\n   * const info = bot.myInfo()\n   */\n  myInfo(): ?BotInfo {\n    return this._service.myInfo()\n  }\n\n  /**\n   * Deinitializes the bot by logging out, stopping the keybase service, and removing any leftover login files made by the bot. This should be run before your bot ends.\n   * @memberof Bot\n   * @example\n   * bot.deinit()\n   */\n  async deinit(): Promise<void> {\n    // Stop the clients first, so that they aren't trying to\n    // talk to a deinit'ed service\n\n    await this.chat._deinit()\n    await this._service.deinit()\n    await rmdirRecursive(this._workingDir)\n  }\n\n  async _prepWorkingDir(): Promise<void> {\n    const keybaseBinaryLocation = await whichKeybase()\n    const destination = path.join(this._workingDir, 'keybase')\n    await promisify(mkdirp)(this._workingDir)\n    await promisify(copyFile)(keybaseBinaryLocation, destination)\n  }\n\n  async _initSubBots(options?: InitOptions) {\n    const info = this.myInfo()\n    if (info) {\n      await this.chat._init(info.homeDir, options)\n      await this.wallet._init(info.homeDir, options)\n    } else {\n      throw new Error('Issue initializing bot.')\n    }\n  }\n}\n\nexport default Bot\n"],"names":["formatAPIObjectInput","obj","apiType","undefined","Array","isArray","map","item","Object","keys","reduce","newObj","key","formattedKey","kebabCase","snakeCase","transformsBlacklist","chat","read","matchBlacklist","context","apiName","method","parentLength","parent","length","matcher","mismatch","matcherIndex","desiredValue","entries","buildContext","copiedContext","slice","push","formatAPIObjectOutput","i","camelCase","keybaseExec","workingDir","homeDir","args","options","stdinBuffer","onStdOut","runArgs","unshift","child","spawn","path","join","stdOutBuffer","stdErrBuffer","stdin","write","end","lineReaderStdout","readline","createInterface","input","stdout","on","chunk","stderr","Promise","resolve","reject","code","finalStdOut","errorMessage","Buffer","concat","toString","Error","json","JSON","parse","e","randomTempDir","name","crypto","randomBytes","os","tmpdir","rmdirRecursive","dirName","fsLstat","promisify","fs","lstat","fsUnlink","unlink","fsRmdir","rmdir","fsReaddir","readdir","dirStat","entry","entryPath","stat","isDirectory","keybaseStatus","status","Username","Device","username","devicename","pingKeybaseService","err","aExec","exec","whichKeybase","trim","res","timeout","time","setTimeout","Service","constructor","initialized","verbose","botLite","disableTyping","init","paperkey","stringify","serviceLogFile","Boolean","startupService","currentInfo","_killCustomService","initFromRunningService","running","deinit","myInfo","env","process","API_VERSIONS","team","wallet","ClientBase","_workingDir","spawnedProcesses","_init","initBotInfo","_deinit","kill","_runApiCommand","arg","params","version","inputString","size","output","alloc","hasOwnProperty","error","message","result","_guardInitialized","_pathToKeybaseBinary","Chat","list","conversations","listChannels","optionsWithDefaults","membersType","channel","peek","unreadOnly","pagination","messages","msg","joinChannel","leaveChannel","send","id","createChannel","attach","filename","download","messageId","react","reaction","body","delete","watchChannelForNewMessages","onMessage","onError","_chatListen","watchAllChannelsForNewMessages","_normalizeNonTeamName","s","Set","toLowerCase","split","add","from","sort","_channelMatch","userWatching","whatCameBack","wantsPublic","public","wantsTopicType","topicType","nameWanted","nameGotten","topicName","hideExploding","onLine","line","messageObject","sender","deviceName","Wallet","balances","history","accountId","cleanedRes","payment","details","transactionId","txid","lookup","recipient","amount","currency","batch","batchId","payments","cancel","Bot","_service","ChatClient","WalletClient","_prepWorkingDir","_initSubBots","keybaseBinaryLocation","destination","mkdirp","copyFile","info"],"mappings":"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"}