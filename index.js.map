{"version":3,"file":"index.js","sources":["lib/utils/formatAPIObject.js","lib/utils/keybaseExec.js","lib/utils/randomTempDir.js","lib/utils/rmdirRecursive.js","lib/utils/keybaseStatus.js","lib/utils/pingKeybaseService.js","lib/utils/whichKeybase.js","lib/utils/timeout.js","lib/service/index.js","lib/constants.js","lib/client-base/index.js","lib/chat-client/index.js","lib/wallet-client/index.js","lib/team-client/index.js","lib/index.js"],"sourcesContent":["// @flow\nimport snakeCase from 'lodash.snakecase'\nimport camelCase from 'lodash.camelcase'\nimport kebabCase from 'lodash.kebabcase'\nimport type {API_TYPES} from '../constants'\n\n/**\n  Takes a Keybase API input JavaScript object and recursively formats it into snake_case or kebab-case instead of camelCase for the service.\n  * @ignore\n  * @param obj - The object to be formatted.\n  * @param apiType - The type of api the the input is being served to. Currently Keybase has chat, team, and wallet apis.\n  * @returns - The new, formatted object.\n  * @example\n  * const inputOptions = formatAPIObject({unreadOnly: true})\n  * console.log(inputOptions) // {unread_only: true}\n */\nexport function formatAPIObjectInput(obj: any, apiType: API_TYPES): any {\n  if (obj === null || obj === undefined || typeof obj !== 'object') {\n    return obj\n  } else if (Array.isArray(obj)) {\n    return obj.map(item => formatAPIObjectInput(item, apiType))\n  } else {\n    return Object.keys(obj).reduce((newObj, key) => {\n      // TODO: hopefully we standardize how the Keybase API handles input keys\n      let formattedKey\n      if (apiType === 'wallet') {\n        formattedKey = kebabCase(key)\n      } else {\n        formattedKey = snakeCase(key)\n      }\n\n      if (typeof obj[key] === 'object') {\n        return {...newObj, [formattedKey]: formatAPIObjectInput(obj[key], apiType)}\n      }\n      return {...newObj, [formattedKey]: obj[key]}\n    }, {})\n  }\n}\n\n/*\n * An internal blacklist of parent levels at which formatAPIObjectOutput transformations\n * shouldn't be performed. A `null` value matches everything.\n */\nconst transformsBlacklist = {\n  chat: {\n    read: [['messages', null, 'msg', 'reactions', 'reactions', null]],\n  },\n}\n\n/**\n * Context of the object formatting process.\n * @ignore\n */\nexport type FormatAPIObjectOutputContext = {|\n  apiName: string,\n  method: string,\n  parent?: any[],\n|}\n\n/*\n * Matches a context against the list of blacklisted parent levels.\n * @ignore\n * @param context - The context to match.\n * @returns - Whether the context is blacklisted from being formatted.\n */\nfunction matchBlacklist(context: ?FormatAPIObjectOutputContext): boolean {\n  if (\n    !context ||\n    !transformsBlacklist[context.apiName] ||\n    !transformsBlacklist[context.apiName][context.method]\n  ) {\n    return false\n  }\n\n  const parentLength = context.parent ? context.parent.length : 0\n\n  for (const matcher of transformsBlacklist[context.apiName][context.method]) {\n    if (matcher.length !== parentLength) {\n      continue\n    }\n\n    // Iterate over the items of the matcher\n    let mismatch = false\n    for (const [matcherIndex, desiredValue] of matcher.entries()) {\n      if (desiredValue === null) {\n        continue\n      }\n\n      if (typeof context.parent === 'object' && context.parent[matcherIndex] !== desiredValue) {\n        mismatch = true\n        break\n      }\n    }\n    if (!mismatch) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/*\n * Appends a new key to the parents array in the formatting context.\n * @ignore\n * @param context - The context to copy and modify.\n * @param key - The key to apprent to the parent array.\n * @returns - A new context.\n */\nfunction buildContext(context: ?FormatAPIObjectOutputContext, key: any): ?FormatAPIObjectOutputContext {\n  if (!context) {\n    return context\n  }\n\n  const copiedContext: FormatAPIObjectOutputContext = {...context}\n  if (!copiedContext.parent) {\n    copiedContext.parent = [key]\n  } else {\n    copiedContext.parent = copiedContext.parent.slice()\n    copiedContext.parent.push(key)\n  }\n\n  return copiedContext\n}\n\n/**\n  Takes a Keybase output object and formats it in a more digestable JavaScript style by using camelCase instead of snake_case.\n  * @ignore\n  * @param obj - The object to be formatted.\n  * @param context - An optional context with information about the called method required to perform blacklist lookups.\n  * @returns - The new, formatted object.\n  * @example\n  * const outputRes = formatAPIObject({unread_only: true})\n  * console.log(outputRes) // {unreadOnly: true}\n */\nexport function formatAPIObjectOutput(obj: any, context?: ?FormatAPIObjectOutputContext): any {\n  if (obj == null || typeof obj !== 'object') {\n    return obj\n  } else if (Array.isArray(obj)) {\n    return obj.map((item, i) => formatAPIObjectOutput(item, buildContext(context, i)))\n  } else {\n    return Object.keys(obj).reduce((newObj, key) => {\n      const formattedKey = matchBlacklist(context) ? key : camelCase(key)\n      if (typeof obj[key] === 'object') {\n        return {...newObj, [formattedKey]: formatAPIObjectOutput(obj[key], buildContext(context, key))}\n      }\n      return {...newObj, [formattedKey]: obj[key]}\n    }, {})\n  }\n}\n","// @flow\nimport {spawn} from 'child_process'\nimport readline from 'readline'\nimport path from 'path'\n\nexport type ExecOptions = {|\n  stdinBuffer?: Buffer | string,\n  onStdOut?: (line: string) => void,\n  json?: boolean,\n  timeout?: number,\n|}\n\nconst keybaseExec = (\n  workingDir: string,\n  homeDir?: string,\n  args: string[],\n  options: ExecOptions = {stdinBuffer: undefined, onStdOut: undefined, timeout: undefined}\n): Promise<any> => {\n  const runArgs: string[] = [...args]\n  if (homeDir) {\n    runArgs.unshift('--home', homeDir)\n  }\n  const keybasePath = path.join(workingDir, 'keybase')\n  const child = spawn(keybasePath, runArgs)\n  const stdOutBuffer: Buffer[] = []\n  const stdErrBuffer: Buffer[] = []\n\n  if (options.stdinBuffer) {\n    child.stdin.write(options.stdinBuffer)\n  }\n  child.stdin.end()\n\n  const lineReaderStdout = readline.createInterface({input: child.stdout})\n\n  // Use readline interface to parse each line (\\n separated) when provided\n  // with onStdOut callback\n  if (options.onStdOut) {\n    lineReaderStdout.on('line', options.onStdOut)\n  } else {\n    child.stdout.on('data', chunk => {\n      stdOutBuffer.push(chunk)\n    })\n  }\n  // Capture STDERR and use as error message if needed\n  child.stderr.on('data', chunk => {\n    stdErrBuffer.push(chunk)\n  })\n\n  let done = false\n  if (options.timeout) {\n    setTimeout(() => {\n      if (!done) {\n        child.kill()\n      }\n    }, options.timeout)\n  }\n\n  return new Promise((resolve, reject) => {\n    child.on('close', code => {\n      done = true\n\n      let finalStdOut: ?string = null\n      // Pass back\n      if (code) {\n        const errorMessage = Buffer.concat(stdErrBuffer).toString('utf8')\n        reject(new Error(errorMessage))\n      } else {\n        const stdout = Buffer.concat(stdOutBuffer).toString('utf8')\n\n        try {\n          finalStdOut = options.json ? JSON.parse(stdout) : stdout\n        } catch (e) {\n          reject(e)\n        }\n      }\n      resolve(finalStdOut)\n    })\n  })\n}\n\nexport default keybaseExec\n","// @flow\nimport os from 'os'\nimport path from 'path'\nimport crypto from 'crypto'\n\nfunction randomTempDir(): string {\n  const name: string = crypto.randomBytes(16).toString('hex')\n  return path.join(os.tmpdir(), `keybase_bot_${name}`)\n}\n\nexport default randomTempDir\n","// @flow\nimport fs from 'fs'\nimport path from 'path'\nimport {promisify} from 'util'\n\nasync function rmdirRecursive(dirName: string): Promise<void> {\n  const fsLstat = promisify(fs.lstat)\n  const fsUnlink = promisify(fs.unlink)\n  const fsRmdir = promisify(fs.rmdir)\n  const fsReaddir = promisify(fs.readdir)\n  const dirStat = await fsLstat(dirName)\n  if (dirStat) {\n    for (const entry of await fsReaddir(dirName)) {\n      const entryPath = path.join(dirName, entry)\n      const stat = await fsLstat(entryPath)\n      if (stat.isDirectory()) {\n        await rmdirRecursive(entryPath)\n      } else {\n        await fsUnlink(entryPath)\n      }\n    }\n    await fsRmdir(dirName)\n  }\n}\n\nexport default rmdirRecursive\n","// @flow\nimport keybaseExec from '../utils/keybaseExec'\n\n/**\n * Useful information like the username, device, home directory of your bot and\n * configuration options.\n */\nexport type BotInfo = {|\n  username: string,\n  devicename: string,\n  homeDir?: string,\n  botLite?: boolean,\n  disableTyping?: boolean,\n|}\n\n/**\n * Returns { username, devicename, homeDir } from `keybase status --json`.\n * @ignore\n * @param workingDir - the directory containing the binary, according to top level Bot\n * @param homeDir - The home directory of the service you want to fetch the status from.\n * @example\n * keybaseStatus('/my/dir').then(status => console.log(status.username))\n */\nasync function keybaseStatus(workingDir: string, homeDir?: string): Promise<BotInfo> {\n  const status = await keybaseExec(workingDir, homeDir, ['status', '--json'], {json: true})\n  if (status && status.Username && status.Device && status.Device.name) {\n    return {\n      username: status.Username,\n      devicename: status.Device.name,\n      homeDir,\n    }\n  } else {\n    throw new Error('Failed to get current username and device name.')\n  }\n}\n\nexport default keybaseStatus\n","// @flow\nimport keybaseExec from '../utils/keybaseExec'\n\n/**\n * Checks whether the keybase service is running by calling `keybase status --json`.\n * @ignore\n * @param workingDir - the directory containing the binary, according to top level Bot\n * @param homeDir - The home directory of the service you want to fetch the status from.\n * @example\n * pingKeybaseService('/my/dir').then(status => console.log(\"service running\", status))\n */\nasync function pingKeybaseService(workingDir: string, homeDir?: string): Promise<boolean> {\n  // TODO: use a faster technique when core releases one\n  try {\n    await keybaseExec(workingDir, homeDir, ['--no-auto-fork', 'status', '--json'], {json: true})\n    return true\n  } catch (err) {\n    return false\n  }\n}\n\nexport default pingKeybaseService\n","// @flow\nimport {exec} from 'child_process'\nimport {promisify} from 'util'\n\nconst aExec = promisify(exec)\n\n/**\n * Returns the full path to the keybase binary or throws an error\n * @ignore\n * @example\n * whichKeybase().then((path) => console.log(path))\n */\nasync function whichKeybase(): Promise<string> {\n  const {stdout} = await aExec('which keybase')\n  if (!stdout || !stdout.trim().length) {\n    throw new Error('Could not find keybase binary')\n  }\n  const res = stdout.trim()\n  return res\n}\n\nexport default whichKeybase\n","// @flow\nfunction timeout(time: number): Promise<void> {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve()\n    }, time)\n  })\n}\n\nexport default timeout\n","// @flow\nimport {keybaseExec, keybaseStatus, pingKeybaseService, timeout} from '../utils'\nimport {spawn} from 'child_process'\nimport type {BotInfo} from '../utils/keybaseStatus'\nimport type {InitOptions} from '../utils/options'\nimport path from 'path'\n\nclass Service {\n  initialized: false | 'paperkey' | 'runningService'\n  running: boolean\n  username: void | string\n  devicename: void | string\n  homeDir: void | string\n  verbose: boolean\n  botLite: boolean\n  disableTyping: boolean\n  serviceLogFile: void | string\n  workingDir: string\n  autoLogSendOnCrash: boolean\n\n  _paperkey: void | string\n\n  constructor(workingDir: string) {\n    this.workingDir = workingDir\n    this.initialized = false\n    this.verbose = false\n    this.botLite = true\n    this.disableTyping = true\n    this.autoLogSendOnCrash = false\n  }\n\n  async init(username: string, paperkey: string, options?: InitOptions): Promise<void> {\n    if (!username || typeof username !== 'string') {\n      throw new Error(`Please provide a username to initialize the bot. Got: ${JSON.stringify(username)}`)\n    }\n    if (!paperkey || typeof paperkey !== 'string') {\n      // Don't want to accidentally print the paperkey to STDERR.\n      throw new Error(`Please provide a paperkey to initialize the bot.`)\n    }\n    if (this.initialized) {\n      throw new Error('Cannot initialize an already initialized bot.')\n    }\n\n    this.homeDir = this.workingDir\n    this.serviceLogFile = path.join(this.homeDir, 'logs', 'keybase.service.log')\n    this.botLite = options ? Boolean(typeof options.botLite !== 'boolean' || options.botLite) : true\n    this.disableTyping = options\n      ? Boolean(typeof options.disableTyping !== 'boolean' || options.disableTyping)\n      : true\n    this.autoLogSendOnCrash = options\n      ? Boolean(typeof options.autoLogSendOnCrash === 'boolean' && options.autoLogSendOnCrash)\n      : false\n    // Unlike with clients we don't need to store the service, since it shuts down with ctrl stop\n    try {\n      await this.startupService()\n      await keybaseExec(this.workingDir, this.homeDir, ['oneshot', '--username', username], {\n        stdinBuffer: paperkey,\n      })\n\n      // Set the typing notification settings for the bot\n      await keybaseExec(this.workingDir, this.homeDir, [\n        'chat',\n        'notification-settings',\n        'disable-typing',\n        this.disableTyping.toString(),\n      ])\n\n      const currentInfo = await keybaseStatus(this.workingDir, this.homeDir)\n\n      if (currentInfo && currentInfo.username && currentInfo.devicename) {\n        this.initialized = 'paperkey'\n        this.username = currentInfo.username\n        this._paperkey = paperkey\n        this.devicename = currentInfo.devicename\n        this.verbose = options ? Boolean(options.verbose) : false\n      }\n      if (this.username !== username) {\n        throw new Error('Failed to initialize service.')\n      }\n    } catch (err) {\n      await this._killCustomService()\n      throw err\n    }\n  }\n\n  async initFromRunningService(homeDir?: string, options?: InitOptions) {\n    if (this.initialized) {\n      throw new Error('Cannot initialize an already initialized bot.')\n    }\n    this.homeDir = homeDir\n\n    const currentInfo = await keybaseStatus(this.workingDir, this.homeDir)\n    if (currentInfo && currentInfo.username && currentInfo.devicename) {\n      this.initialized = 'runningService'\n      this.username = currentInfo.username\n      this.devicename = currentInfo.devicename\n      this.verbose = options ? Boolean(options.verbose) : false\n    }\n  }\n\n  async _killCustomService(): Promise<void> {\n    // these 2 commands might be unnecessary; since the service was `spawn`ed not detached\n    // they will also shutdown via SIGINT. We don't want to make service detached because it'd be nice for\n    // them to auto-shutdown if the user kills the process\n    try {\n      await keybaseExec(this.workingDir, this.homeDir, ['logout'])\n    } catch (e) {}\n    try {\n      await keybaseExec(this.workingDir, this.homeDir, ['ctl', 'stop', '--shutdown'])\n    } catch (e) {}\n    // wait until the process quits by watching the running property\n    let i = 0\n    while (true) {\n      await timeout(100)\n\n      if (!this.running) {\n        break\n      }\n\n      if (++i >= 100) {\n        throw new Error(`The service didn't finish shutting down in time (${this.workingDir})`)\n      }\n    }\n  }\n\n  async deinit(): Promise<void> {\n    if (!this.initialized) {\n      throw new Error('Cannot deinitialize an uninitialized bot.')\n    }\n    // If we init the bot using paperkey credentials, then we want to stop the service and remove our generated directory.\n    if (this.initialized === 'paperkey') {\n      await this._killCustomService()\n    }\n    this.initialized = false\n  }\n\n  myInfo(): ?BotInfo {\n    if (this.username && this.devicename) {\n      return {\n        username: this.username,\n        devicename: this.devicename,\n        homeDir: this.homeDir ? this.homeDir : undefined,\n        botLite: this.botLite,\n        disableTyping: this.disableTyping,\n      }\n    }\n    return null\n  }\n\n  /**\n   *\n   * @ignore\n   * This is a bit different from normal keybaseExecs and is unique to the service\n   * starting up\n   * @example\n   * service.startupService()\n   */\n  async startupService(): Promise<void> {\n    const args = ['service']\n    if (this.homeDir) {\n      args.unshift('--home', this.homeDir)\n    }\n    if (this.serviceLogFile) {\n      args.unshift('--log-file', this.serviceLogFile)\n    }\n    if (this.botLite) {\n      args.unshift('--enable-bot-lite-mode')\n    }\n\n    const child = spawn(path.join(this.workingDir, 'keybase'), args, {env: process.env})\n\n    // keep track of the subprocess' state\n    this.running = true\n    child.on('exit', async code => {\n      this.running = false\n      if (code !== 0 && this.autoLogSendOnCrash) {\n        await this.logSend()\n      }\n    })\n\n    return new Promise(async (resolve, reject) => {\n      child.on('close', code => {\n        // any code here including 0 is bad here, if it happens before resolve\n        //, since this service should stay running\n        reject(new Error(`keybase service exited with code ${code} (${this.workingDir})`))\n      })\n\n      // Wait for the service to start up - give it 10s.\n      let i = 0\n      while (!(await pingKeybaseService(this.workingDir, this.homeDir))) {\n        await timeout(100)\n        if (++i >= 100) {\n          throw new Error(\"Couldn't start up service fast enough\")\n        }\n      }\n      resolve()\n    })\n  }\n\n  async logSend(): Promise<void> {\n    const initiallyRunning = this.running\n    if (!initiallyRunning) {\n      try {\n        await this.startupService()\n        if (this.initialized === 'paperkey' && this.username) {\n          await keybaseExec(this.workingDir, this.homeDir, ['oneshot', '--username', this.username], {\n            stdinBuffer: this._paperkey,\n          })\n        }\n      } catch (e) {}\n    }\n\n    const feedback = `keybase-bot auto log send\nusername: ${this.username || 'none'}\ninitialized: ${this.initialized || 'false'}`\n\n    const args = ['log', 'send', '--no-confirm', '--feedback', feedback]\n    if (this.serviceLogFile) {\n      args.unshift('--log-file', this.serviceLogFile)\n    }\n    await keybaseExec(this.workingDir, this.homeDir, args)\n\n    if (!initiallyRunning) {\n      await this._killCustomService()\n    }\n  }\n}\n\nexport default Service\n","// @flow\nexport const API_VERSIONS = {\n  chat: 1,\n  team: 1,\n  wallet: 1,\n}\n\nexport type API_TYPES = 'chat' | 'team' | 'wallet'\n","// @flow\nimport type {ChildProcess} from 'child_process'\nimport {formatAPIObjectInput, formatAPIObjectOutput, keybaseExec, keybaseStatus} from '../utils'\nimport type {InitOptions} from '../utils/options'\nimport {API_VERSIONS, type API_TYPES} from '../constants'\nimport path from 'path'\n\nexport type ApiCommandArg = {|\n  apiName: API_TYPES,\n  method: string,\n  options?: Object,\n  timeout?: number,\n|}\n\n/**\n * A Client base.\n * @ignore\n */\nclass ClientBase {\n  initialized: boolean\n  username: void | string\n  devicename: void | string\n  homeDir: void | string\n  verbose: boolean\n  spawnedProcesses: ChildProcess[]\n  _workingDir: string\n\n  constructor(workingDir: string) {\n    this._workingDir = workingDir\n    this.initialized = false\n    this.verbose = false\n    this.spawnedProcesses = []\n  }\n\n  async _init(homeDir: void | string, options?: InitOptions): Promise<void> {\n    const initBotInfo = await keybaseStatus(this._workingDir, homeDir)\n    this.homeDir = homeDir\n    this.username = initBotInfo.username\n    this.devicename = initBotInfo.devicename\n    this.initialized = true\n  }\n\n  async _deinit(): Promise<void> {\n    for (const child of this.spawnedProcesses) {\n      child.kill()\n    }\n  }\n\n  async _runApiCommand(arg: ApiCommandArg): Promise<any> {\n    const options = arg.options ? formatAPIObjectInput(arg.options, arg.apiName) : undefined\n    const input = {\n      method: arg.method,\n      params: {\n        version: API_VERSIONS[arg.apiName],\n        options,\n      },\n    }\n    const inputString = JSON.stringify(input)\n    const size = inputString.length\n    const output = await keybaseExec(this._workingDir, this.homeDir, [arg.apiName, 'api'], {\n      stdinBuffer: Buffer.alloc(size, inputString, 'utf8'),\n      json: true,\n      timeout: arg.timeout,\n    })\n    if (output.hasOwnProperty('error')) {\n      throw new Error(output.error.message)\n    }\n    const res = formatAPIObjectOutput(output.result, {\n      apiName: arg.apiName,\n      method: arg.method,\n    })\n    return res\n  }\n\n  async _guardInitialized(): Promise<void> {\n    if (!this.initialized) {\n      throw new Error('The client is not yet initialized.')\n    }\n  }\n  _pathToKeybaseBinary(): string {\n    return path.join(this._workingDir, 'keybase')\n  }\n}\n\nexport default ClientBase\n","// @flow\nimport {spawn} from 'child_process'\nimport readline from 'readline'\nimport ClientBase from '../client-base'\nimport {formatAPIObjectOutput, formatAPIObjectInput} from '../utils'\nimport type {\n  ChatConversation,\n  ChatChannel,\n  ChatMessage,\n  MessageSummary,\n  ListenOptions,\n  ReadResult,\n  SendResult,\n  ChatListOptions,\n  ChatListChannelsOptions,\n  ChatReadOptions,\n  ChatSendOptions,\n  ChatAttachOptions,\n  ChatDownloadOptions,\n  ChatDeleteOptions,\n  ChatReactOptions,\n  MessageNotification,\n  UnfurlMode,\n  FlipSummary,\n} from './types'\n\n/** A function to call when a message is received. */\nexport type OnMessage = (message: MessageSummary) => void | Promise<void>\n/** A function to call when an error occurs. */\nexport type OnError = (error: Error) => void | Promise<void>\n\n/** The chat module of your Keybase bot. For more info about the API this module uses, you may want to check out `keybase chat api`. */\nclass Chat extends ClientBase {\n  /**\n   * Lists your chats, with info on which ones have unread messages.\n   * @memberof Chat\n   * @param options - An object of options that can be passed to the method.\n   * @returns - An array of chat conversations. If there are no conversations, the array is empty.\n   * @example\n   * bot.chat.list({unreadOnly: true}).then(chatConversations => console.log(chatConversations))\n   */\n  async list(options?: ChatListOptions): Promise<ChatConversation[]> {\n    await this._guardInitialized()\n    const res = await this._runApiCommand({apiName: 'chat', method: 'list', options})\n    if (!res) {\n      throw new Error('Keybase chat list returned nothing.')\n    }\n    return res.conversations || []\n  }\n\n  /**\n   * Lists conversation channels in a team\n   * @memberof Chat\n   * @param name - Name of the team\n   * @param options - An object of options that can be passed to the method.\n   * @returns - An array of chat conversations. If there are no conversations, the array is empty.\n   * @example\n   * bot.chat.listChannels('team_name').then(chatConversations => console.log(chatConversations))\n   */\n  async listChannels(name: string, options?: ChatListChannelsOptions): Promise<ChatConversation[]> {\n    await this._guardInitialized()\n    const optionsWithDefaults = {\n      ...options,\n      name,\n      membersType: options && options.membersType ? options.membersType : 'team',\n    }\n    const res = await this._runApiCommand({\n      apiName: 'chat',\n      method: 'listconvsonname',\n      options: optionsWithDefaults,\n    })\n    if (!res) {\n      throw new Error('Keybase chat list convs on name returned nothing.')\n    }\n    return res.conversations || []\n  }\n\n  /**\n   * Reads the messages in a channel. You can read with or without marking as read.\n   * @memberof Chat\n   * @param channel - The chat channel to read messages in.\n   * @param options - An object of options that can be passed to the method.\n   * @returns - A summary of data about a message, including who send it, when, the content of the message, etc. If there are no messages in your channel, then an error is thrown.\n   * @example\n   * alice.chat.read(channel).then(messages => console.log(messages))\n   */\n  async read(channel: ChatChannel, options?: ChatReadOptions): Promise<ReadResult> {\n    await this._guardInitialized()\n    const optionsWithDefaults = {\n      ...options,\n      channel,\n      peek: options && options.peek ? options.peek : false,\n      unreadOnly: options && options.unreadOnly !== undefined ? options.unreadOnly : false,\n    }\n    const res = await this._runApiCommand({apiName: 'chat', method: 'read', options: optionsWithDefaults})\n    if (!res) {\n      throw new Error('Keybase chat read returned nothing.')\n    }\n    // Pagination gets passed as-is, while the messages get cleaned up\n    return {\n      pagination: res.pagination,\n      messages: res.messages.map(message => message.msg),\n    }\n  }\n\n  /**\n   * Joins a team conversation.\n   * @param channel - The team chat channel to join.\n   * @example\n   * bot.chat.listConvsOnName('team_name').then(async teamConversations => {\n   *  for (const conversation of teamConversations) {\n   *    if (conversation.memberStatus !== 'active') {\n   *      await bot.chat.join(conversation.channel)\n   *      console.log('Joined team channel', conversation.channel)\n   *    }\n   *  }\n   * })\n   */\n  async joinChannel(channel: ChatChannel): Promise<void> {\n    await this._guardInitialized()\n    const res = await this._runApiCommand({\n      apiName: 'chat',\n      method: 'join',\n      options: {\n        channel,\n      },\n    })\n    if (!res) {\n      throw new Error('Keybase chat join returned nothing')\n    }\n  }\n\n  /**\n   * Leaves a team conversation.\n   * @param channel - The team chat channel to leave.\n   * @example\n   * bot.chat.listConvsOnName('team_name').then(async teamConversations => {\n   *  for (const conversation of teamConversations) {\n   *    if (conversation.memberStatus === 'active') {\n   *      await bot.chat.leave(conversation.channel)\n   *      console.log('Left team channel', conversation.channel)\n   *    }\n   *  }\n   * })\n   */\n  async leaveChannel(channel: ChatChannel): Promise<void> {\n    await this._guardInitialized()\n    const res = await this._runApiCommand({\n      apiName: 'chat',\n      method: 'leave',\n      options: {\n        channel,\n      },\n    })\n    if (!res) {\n      throw new Error('Keybase chat leave returned nothing')\n    }\n  }\n\n  /**\n   * Send a message to a certain channel.\n   * @memberof Chat\n   * @param channel - The chat channel to send the message in.\n   * @param message - The chat message to send.\n   * @param options - An object of options that can be passed to the method.\n   * @example\n   * const channel = {name: 'kbot,' + bot.myInfo().username, public: false, topicType: 'chat'}\n   * const message = {body: 'Hello kbot!'}\n   * bot.chat.send(channel, message).then(() => console.log('message sent!'))\n   */\n  async send(channel: ChatChannel, message: ChatMessage, options?: ChatSendOptions): Promise<SendResult> {\n    await this._guardInitialized()\n    const args = {\n      ...options,\n      channel,\n      message,\n    }\n    const res = await this._runApiCommand({\n      apiName: 'chat',\n      method: 'send',\n      options: args,\n    })\n    if (!res) {\n      throw new Error('Keybase chat send returned nothing')\n    }\n\n    return {id: res.id}\n  }\n\n  /**\n   * Creates a new blank conversation.\n   * @memberof Chat\n   * @param channel - The chat channel to create.\n   * @example\n   * bot.chat.createChannel(channel).then(() => console.log('conversation created'))\n   */\n  async createChannel(channel: ChatChannel): Promise<void> {\n    await this._guardInitialized()\n    const args = {\n      channel,\n    }\n    const res = await this._runApiCommand({\n      apiName: 'chat',\n      method: 'newconv',\n      options: args,\n    })\n    if (!res) {\n      throw new Error('Keybase chat newconv returned nothing')\n    }\n  }\n\n  /**\n   * Send a file to a channel.\n   * @memberof Chat\n   * @param channel - The chat channel to send the message in.\n   * @param filename - The absolute path of the file to send.\n   * @param options - An object of options that can be passed to the method.\n   * @example\n   * bot.chat.attach(channel, '/Users/nathan/my_picture.png').then(() => console.log('Sent a picture!'))\n   */\n  async attach(channel: ChatChannel, filename: string, options: ChatAttachOptions): Promise<SendResult> {\n    await this._guardInitialized()\n    const args = {...options, channel, filename}\n    const res = await this._runApiCommand({apiName: 'chat', method: 'attach', options: args})\n    if (!res) {\n      throw new Error('Keybase chat attach returned nothing')\n    }\n\n    return {id: res.id}\n  }\n\n  /**\n   * Download a file send via Keybase chat.\n   * @memberof Chat\n   * @param channel - The chat channel that the desired attacment to download is in.\n   * @param messageId - The message id of the attached file.\n   * @param output - The absolute path of where the file should be downloaded to.\n   * @param options - An object of options that can be passed to the method\n   * @example\n   * bot.chat.download(channel, 325, '/Users/nathan/Downloads/file.png')\n   */\n  async download(channel: ChatChannel, messageId: number, output: string, options: ChatDownloadOptions) {\n    await this._guardInitialized()\n    const args = {...options, channel, messageId, output}\n    const res = await this._runApiCommand({apiName: 'chat', method: 'download', options: args})\n    if (!res) {\n      throw new Error('Keybase chat download returned nothing')\n    }\n  }\n\n  /**\n   * Reacts to a given message in a channel. Messages have messageId's associated with\n   * them, which you can learn in `bot.chat.read`.\n   * @memberof Chat\n   * @param channel - The chat channel to send the message in.\n   * @param messageId - The id of the message to react to.\n   * @param reaction - The reaction emoji, in colon form.\n   * @param options - An object of options that can be passed to the method.\n   * @example\n   * bot.chat.react(channel, 314, ':+1:').then(() => console.log('Thumbs up!'))\n   */\n  async react(\n    channel: ChatChannel,\n    messageId: number,\n    reaction: string,\n    options?: ChatReactOptions\n  ): Promise<SendResult> {\n    await this._guardInitialized()\n    const args = {\n      ...options,\n      channel,\n      messageId,\n      message: {body: reaction},\n    }\n    const res = await this._runApiCommand({apiName: 'chat', method: 'reaction', options: args})\n    if (!res) {\n      throw new Error('Keybase chat react returned nothing.')\n    }\n\n    return {id: res.id}\n  }\n\n  /**\n   * Deletes a message in a channel. Messages have messageId's associated with\n   * them, which you can learn in `bot.chat.read`. Known bug: the GUI has a cache,\n   * and deleting from the CLI may not become apparent immediately.\n   * @memberof Chat\n   * @param channel - The chat channel to send the message in.\n   * @param messageId - The id of the message to delete.\n   * @param options - An object of options that can be passed to the method.\n   * @example\n   * bot.chat.delete(channel, 314).then(() => console.log('message deleted!'))\n   */\n  async delete(channel: ChatChannel, messageId: number, options?: ChatDeleteOptions): Promise<void> {\n    await this._guardInitialized()\n    const args = {\n      ...options,\n      channel,\n      messageId,\n    }\n    const res = await this._runApiCommand({apiName: 'chat', method: 'delete', options: args})\n    if (!res) {\n      throw new Error('Keybase chat delete returned nothing.')\n    }\n  }\n\n  /**\n   * Gets current unfurling settings\n   * @example\n   * bot.chat.getUnfurlSettings().then((mode) => console.log(mode))\n   */\n  async getUnfurlSettings(): Promise<UnfurlMode> {\n    await this._guardInitialized()\n    const res = await this._runApiCommand({apiName: 'chat', method: 'getunfurlsettings', options: {}})\n    if (!res) {\n      throw new Error('Keybase chat get unfurl mode returned nothing.')\n    }\n    return res\n  }\n\n  /**\n   * Sets the unfurling mode\n   * @param mode - the new unfurl mode\n   * @example\n   * bot.chat.setUnfurlMode({\n   *   \"mode\": \"always\",\n   * }).then((mode) => console.log('mode updated!'))\n   */\n  async setUnfurlSettings(mode: UnfurlMode): Promise<void> {\n    await this._guardInitialized()\n    const res = await this._runApiCommand({apiName: 'chat', method: 'setunfurlsettings', options: mode})\n    if (!res) {\n      throw new Error('Keybase chat set unfurl mode returned nothing.')\n    }\n  }\n\n  /**\n   * Loads a flip's details\n   * @param conversationID - conversation ID received in API listen.\n   * @param flipConversationID - flipConvID from the message summary.\n   * @param messageID - ID of the message in the conversation.\n   * @param gameID - gameID from the flip message contents.\n   */\n  async loadFlip(\n    conversationID: string,\n    flipConversationID: string,\n    messageID: number,\n    gameID: string,\n  ): Promise<FlipSummary> {\n    await this._guardInitialized()\n    const res = await this._runApiCommand({\n      apiName: 'chat',\n      method: 'loadflip',\n      options: {\n        \"conversation_id\": conversationID,\n        \"flip_conversation_id\": flipConversationID,\n        \"msg_id\": messageID,\n        \"game_id\": gameID,\n      },\n      timeout: 2000,\n    })\n    if (!res) {\n      throw new Error('Keybase chat load flip returned nothing.')\n    }\n    return res.status\n  }\n\n  /**\n   * Listens for new chat messages on a specified channel. The `onMessage` function is called for every message your bot receives. This is pretty similar to `watchAllChannelsForNewMessages`, except it specifically checks one channel. Note that it receives messages your own bot posts, but from other devices. You can filter out your own messages by looking at a message's sender object.\n   * Hides exploding messages by default.\n   * @memberof Chat\n   * @param channel - The chat channel to watch.\n   * @param onMessage - A callback that is triggered on every message your bot receives.\n   * @param onError - A callback that is triggered on any error that occurs while the method is executing.\n   * @param options - Options for the listen method.\n   * @example\n   * // Reply to all messages between you and `kbot` with 'thanks!'\n   * const channel = {name: 'kbot,' + bot.myInfo().username, public: false, topicType: 'chat'}\n   * const onMessage = message => {\n   *   const channel = message.channel\n   *   bot.chat.send(channel, {body: 'thanks!!!'})\n   * }\n   * bot.chat.watchChannelForNewMessages(channel, onMessage)\n   */\n  async watchChannelForNewMessages(\n    channel: ChatChannel,\n    onMessage: OnMessage,\n    onError?: OnError,\n    options?: ListenOptions\n  ): Promise<void> {\n    await this._guardInitialized()\n    this._chatListen(onMessage, onError, channel, options)\n  }\n\n  /**\n   * This function will put your bot into full-read mode, where it reads\n   * everything it can and every new message it finds it will pass to you, so\n   * you can do what you want with it. For example, if you want to write a\n   * Keybase bot that talks shit at anyone who dares approach it, this is the\n   * function to use. Note that it receives messages your own bot posts, but from other devices.\n   * You can filter out your own messages by looking at a message's sender object.\n   * Hides exploding messages by default.\n   * @memberof Chat\n   * @param onMessage - A callback that is triggered on every message your bot receives.\n   * @param onError - A callback that is triggered on any error that occurs while the method is executing.\n   * @param options - Options for the listen method.\n   * @example\n   * // Reply to incoming traffic on all channels with 'thanks!'\n   * const onMessage = message => {\n   *   const channel = message.channel\n   *   bot.chat.send(channel, {body: 'thanks!!!'})\n   * }\n   * bot.chat.watchAllChannelsForNewMessages(onMessage)\n   *\n   */\n  async watchAllChannelsForNewMessages(\n    onMessage: OnMessage,\n    onError?: OnError,\n    options?: ListenOptions\n  ): Promise<void> {\n    await this._guardInitialized()\n    this._chatListen(onMessage, onError, undefined, options)\n  }\n\n  /**\n   * Spawns the chat listen process and handles the calling of onMessage, onError, and filtering for a specific channel.\n   * @memberof Chat\n   * @ignore\n   * @param onMessage - A callback that is triggered on every message your bot receives.\n   * @param onError - A callback that is triggered on any error that occurs while the method is executing.\n   * @param channel - The chat channel to watch.\n   * @param options - Options for the listen method.\n   * @example\n   * this._chatListen(onMessage, onError)\n   */\n  _chatListen(onMessage: OnMessage, onError?: OnError, channel?: ChatChannel, options?: ListenOptions): void {\n    const args = ['chat', 'api-listen']\n    if (this.homeDir) {\n      args.unshift('--home', this.homeDir)\n    }\n    if (!options || (options && options.hideExploding !== false)) {\n      args.push('--hide-exploding')\n    }\n    if (channel) {\n      args.push('--filter-channel', JSON.stringify(formatAPIObjectInput(channel, 'chat')))\n    }\n    const child = spawn(this._pathToKeybaseBinary(), args)\n    this.spawnedProcesses.push(child)\n\n    const lineReaderStdout = readline.createInterface({input: child.stdout})\n    const onLine = (line: string) => {\n      try {\n        const messageObject: MessageNotification = formatAPIObjectOutput(JSON.parse(line))\n        if (messageObject.hasOwnProperty('error')) {\n          throw new Error(messageObject.error)\n        } else if (\n          // fire onMessage if it was from a different sender or at least a different device\n          // from this sender. Bots can filter out their own messages from other devices.\n          this.username &&\n          this.devicename &&\n          (messageObject.msg.sender.username !== this.username.toLowerCase() ||\n            messageObject.msg.sender.deviceName !== this.devicename)\n        ) {\n          onMessage(messageObject.msg)\n        }\n      } catch (error) {\n        if (onError) {\n          onError(error)\n        }\n      }\n    }\n    lineReaderStdout.on('line', onLine)\n  }\n}\n\nexport default Chat\n","// @flow\nimport ClientBase from '../client-base'\nimport type {Account, Transaction, PaymentBatchItem, BatchResult} from './types'\n\n/** The wallet module of your Keybase bot. For more info about the API this module uses, you may want to check out `keybase wallet api`. */\nclass Wallet extends ClientBase {\n  /**\n   * Provides a list of all accounts owned by the current Keybase user.\n   * @memberof Wallet\n   * @returns - An array of accounts. If there are no accounts, the array is empty.\n   * @example\n   * bot.wallet.balances().then(accounts => console.log(accounts))\n   */\n  async balances(): Promise<Account[]> {\n    await this._guardInitialized()\n    const res = await this._runApiCommand({apiName: 'wallet', method: 'balances'})\n    if (!res) {\n      throw new Error('Keybase wallet balanaces returned nothing.')\n    }\n    return res || []\n  }\n\n  /**\n   * Provides a list of all transactions in a single account.\n   * @memberof Wallet\n   * @param accountId - The id of an account owned by a Keybase user.\n   * @returns - An array of transactions related to the account.\n   * @example\n   * bot.wallet.history('GDUKZH6Q3U5WQD4PDGZXYLJE3P76BDRDWPSALN4OUFEESI2QL5UZHCK').then(transactions => console.log(transactions))\n   */\n  async history(accountId: string): Promise<Transaction[]> {\n    await this._guardInitialized()\n    const options = {\n      accountId,\n    }\n    const res = await this._runApiCommand({apiName: 'wallet', method: 'history', options: options})\n    if (!res) {\n      throw new Error('Keybase wallet history returned nothing.')\n    }\n    // Removes a single object with property `payment`\n    const cleanedRes = res.map(payment => payment.payment)\n    return cleanedRes\n  }\n\n  /**\n   * Get details about a particular transaction\n   * @memberof Wallet\n   * @param transactionId - The id of the transaction you would like details about.\n   * @returns - An object of details about the transaction specified.\n   * @example\n   * bot.wallet.details('e5334601b9dc2a24e031ffeec2fce37bb6a8b4b51fc711d16dec04d3e64976c4').then(details => console.log(details))\n   */\n  async details(transactionId: string): Promise<Transaction> {\n    await this._guardInitialized()\n    const options = {txid: transactionId}\n    const res = await this._runApiCommand({apiName: 'wallet', method: 'details', options: options})\n    if (!res) {\n      throw new Error('Keybase wallet details returned nothing.')\n    }\n    return res\n  }\n\n  /**\n   * Lookup the primary Stellar account ID of a Keybase user.\n   * @memberof Wallet\n   * @param name - The name of the user you want to lookup. This can be either a Keybase username or a username of another account that is supported by Keybase if it is followed by an '@<service>'.\n   * @returns - An object containing the account ID and Keybase username of the found user.\n   * @example\n   * const lookup1 = bot.wallet.lookup('patrick')\n   * // 'patrick' on Keybase is 'patrickxb' on twitter\n   * const lookup2 = bot.wallet.lookup('patrcikxb@twitter')\n   * // Using Lodash's `isEqual` since objects with same values aren't equal in JavaScript\n   * _.isEqual(lookup1, lookup2) // => true\n   */\n  async lookup(name: string): Promise<{|accountID: string, username: string|}> {\n    await this._guardInitialized()\n    const options = {name}\n    const res = await this._runApiCommand({apiName: 'wallet', method: 'lookup', options})\n    if (!res) {\n      throw new Error('Keybase wallet lookup returned nothing.')\n    }\n    return res\n  }\n\n  /**\n   * Send lumens (XLM) via Keybase with your bot!\n   * @memberof Wallet\n   * @param recipient - Who you're sending your money to. This can be a Keybase user, stellar address, or a username of another account that is supported by Keybase if it is followed by an '@<service>'.\n   * @param amount - The amount of XLM to send.\n   * @param [currency] - Adds a currency value to the amount specified. For example, adding 'USD' would send\n   * @param [message] - The message for your payment\n   * @returns - The trasaction object of the transaction.\n   * @example\n   * bot.wallet.send('nathunsmitty', '3.50') // Send 3.50 XLM to Keybase user `nathunsmitty`\n   * bot.wallet.send('nathunsmitty@github', '3.50') // Send 3.50 XLM to GitHub user `nathunsmitty`\n   * bot.wallet.send('nathunsmitty', '3.50', 'USD') // Send $3.50 worth of lumens to Keybase user `nathunsmitty`\n   * bot.wallet.send('nathunsmitty', '3.50', 'USD', 'Shut up and take my money!') // Send $3.50 worth of lumens to Keybase user `nathunsmitty` with a memo\n   */\n  async send(recipient: string, amount: string, currency?: string, message?: string): Promise<Transaction> {\n    await this._guardInitialized()\n    const options = {recipient, amount, currency, message}\n    const res = await this._runApiCommand({apiName: 'wallet', method: 'send', options})\n    if (!res) {\n      throw new Error('Keybase wallet send returned nothing.')\n    }\n    return res\n  }\n\n  /**\n   * Send lumens (XLM) via Keybase to more than one user at once. As opposed to the normal bot.wallet.send\n   * command, this can get multiple transactions into the same 5-second Stellar ledger.\n   * @memberof Wallet\n   * @param batchId - example, if sending a bunch of batches for an airdrop, you could pass them all `airdrop2025`.\n   * @param payments - an array of objects containing recipients and XLM of the form {\"recipient\": \"someusername\", \"amount\": \"1.234\", \"message\", \"hi there\"}\n   * @returns - an object\n   * @example\n   * bot.wallet.batch(\"airdrop2040\",[{\"recipient\":\"a1\",\"amount\": \"1.414\", \"message\": \"hi a1, yes 1\"},{\"recipient\": \"a2\", \"amount\": \"3.14159\", \"message\": \"hi a2, yes 2\"},}])\n   */\n\n  async batch(batchId: string, payments: PaymentBatchItem[]): Promise<BatchResult> {\n    await this._guardInitialized()\n    const options = {batchId, payments}\n    const res = await this._runApiCommand({apiName: 'wallet', method: 'batch', options})\n    if (!res) {\n      throw new Error('Keybase wallet batch returned nothing.')\n    }\n    return res\n  }\n\n  /**\n   * If you send XLM to a Keybase user who has not established a wallet, you can cancel the payment before the recipient claims it and the XLM will be returned to your account.\n   * @memberof Wallet\n   * @param transactionId - The id of the transaction to cancel.\n   * @example\n   * bot.wallet.cancel('e5334601b9dc2a24e031ffeec2fce37bb6a8b4b51fc711d16dec04d3e64976c4').then(() => console.log('Transaction successfully canceled!'))\n   */\n  async cancel(transactionId: string): Promise<void> {\n    await this._guardInitialized()\n    const options = {txid: transactionId}\n    const res = await this._runApiCommand({apiName: 'wallet', method: 'cancel', options})\n    if (!res) {\n      throw new Error('Keybase wallet cancel returned nothing.')\n    }\n  }\n}\n\nexport default Wallet\n","// @flow\nimport ClientBase from '../client-base'\nimport type {\n  AddMembersParam,\n  RemoveMemberParam,\n  ListTeamMembershipsParam,\n  AddMembersResult,\n  RemoveMemberResult,\n  ListTeamMembershipsResult,\n} from './types'\n\n/** The wallet module of your Keybase bot. For more info about the API this module uses, you may want to check out `keybase wallet api`. */\nclass Team extends ClientBase {\n  /**\n   * Add a bunch of people with different privileges to a team\n   * @memberof Team\n   * @param additions - an array of the users to add, with privs\n   * @returns -\n   * @example\n   * bot.team.addMembers({\"team\": \"phoenix\", \"emails\": [{\"email\": \"alice@keybase.io\", \"role\": \"writer\"}, {\"email\": \"cleo@keybase.io\", \"role\": \"admin\"}], \"usernames\": [{\"username\": \"frank\", \"role\": \"reader\"}, {\"username\": \"keybaseio@twitter\", \"role\": \"writer\"}]}).then(res => console.log(res))\n   */\n  async addMembers(additions: AddMembersParam): Promise<AddMembersResult> {\n    await this._guardInitialized()\n    const options = additions\n    const res = await this._runApiCommand({apiName: 'team', method: 'add-members', options})\n    if (!res) {\n      throw new Error('addMembers')\n    }\n    return res\n  }\n\n  /**\n   * Remove someone from a team\n   * @memberof Team\n   * @param removal - object with the `team` name and `username`\n   * @returns -\n   * @example\n   * bot.team.removeMember({\"team\": \"phoenix\", \"username\": \"frank\"}).then(res => console.log(res))\n   */\n  async removeMember(removal: RemoveMemberParam): Promise<RemoveMemberResult> {\n    await this._guardInitialized()\n    const options = removal\n    const res = await this._runApiCommand({apiName: 'team', method: 'remove-member', options})\n    return res\n  }\n\n  /**\n   * List a team's members\n   * @memberof Team\n   * @param team - an object with the `team` name in it\n   * @returns -\n   * @example\n   * bot.team.listTeamMemberships({\"team\": \"phoenix\"}).then(res => console.log(res))\n   */\n  async listTeamMemberships(team: ListTeamMembershipsParam): Promise<ListTeamMembershipsResult> {\n    await this._guardInitialized()\n    const options = team\n    const res = await this._runApiCommand({apiName: 'team', method: 'list-team-memberships', options})\n    if (!res) {\n      throw new Error('listTeamMemberships')\n    }\n    return res\n  }\n}\n\nexport default Team\n","// @flow\nimport Service from './service'\nimport ChatClient from './chat-client'\nimport WalletClient from './wallet-client'\nimport TeamClient from './team-client'\nimport type {BotInfo} from './utils/keybaseStatus'\nimport mkdirp from 'mkdirp'\nimport {randomTempDir, whichKeybase, rmdirRecursive} from './utils'\nimport {promisify} from 'util'\nimport {copyFile} from 'fs'\nimport path from 'path'\nimport type {InitOptions} from './utils/options'\n\n/** A Keybase bot. */\nclass Bot {\n  chat: ChatClient\n  wallet: WalletClient\n  team: TeamClient\n  _workingDir: string // where KB binary copied, and homeDir (if not existing svc)\n  _service: Service\n\n  /**\n   * Create a bot. Note you can't do much too exciting with your bot after you instantiate it; you have to initialize it first.\n   * @memberof Bot\n   * @example\n   * const bot = new Bot()\n   */\n  constructor() {\n    this._workingDir = randomTempDir()\n    this._service = new Service(this._workingDir)\n    this.chat = new ChatClient(this._workingDir)\n    this.wallet = new WalletClient(this._workingDir)\n    this.team = new TeamClient(this._workingDir)\n  }\n\n  /**\n   * Initialize your bot by starting an instance of the Keybase service and logging in using oneshot mode.\n   * @memberof Bot\n   * @param username - The username of your bot's Keybase account.\n   * @param paperkey - The paperkey of your bot's Keybase account.\n   * @param options - The initialization options for your bot.\n   * @example\n   * bot.init('username', 'paperkey')\n   */\n  async init(username: string, paperkey: string, options?: InitOptions): Promise<void> {\n    await this._prepWorkingDir()\n    await this._service.init(username, paperkey, options)\n    await this._initSubBots(options)\n  }\n\n  /**\n   * Initialize your bot by using an existing running service with a logged in user.\n   * @memberof Bot\n   * @param homeDir - The home directory of this currently running service. Leave blank to use the default homeDir for your system.\n   * @param options - The initialization options for your bot.\n   * @example\n   * bot.initFromRunningService()\n   */\n  async initFromRunningService(homeDir?: string, options?: InitOptions): Promise<void> {\n    await this._prepWorkingDir()\n    await this._service.initFromRunningService(homeDir, options)\n    await this._initSubBots(options)\n  }\n\n  /**\n   * Get info about your bot!\n   * @memberof Bot\n   * @returns – Useful information like the username, device, and home directory of your bot. If your bot isn't initialized, you'll get `null`.\n   * @example\n   * const info = bot.myInfo()\n   */\n  myInfo(): ?BotInfo {\n    return this._service.myInfo()\n  }\n\n  /**\n   * Deinitializes the bot by logging out, stopping the keybase service, and removing any leftover login files made by the bot. This should be run before your bot ends.\n   * @memberof Bot\n   * @example\n   * bot.deinit()\n   */\n  async deinit(): Promise<void> {\n    // Stop the clients first, so that they aren't trying to\n    // talk to a deinit'ed service\n\n    await this.chat._deinit()\n    await this._service.deinit()\n    await rmdirRecursive(this._workingDir)\n  }\n\n  async _prepWorkingDir(): Promise<void> {\n    const keybaseBinaryLocation = await whichKeybase()\n    const destination = path.join(this._workingDir, 'keybase')\n    await promisify(mkdirp)(this._workingDir)\n    await promisify(copyFile)(keybaseBinaryLocation, destination)\n  }\n\n  async _initSubBots(options?: InitOptions) {\n    const info = this.myInfo()\n    if (info) {\n      await this.chat._init(info.homeDir, options)\n      await this.wallet._init(info.homeDir, options)\n      await this.team._init(info.homeDir, options)\n    } else {\n      throw new Error('Issue initializing bot.')\n    }\n  }\n}\n\nexport default Bot\n"],"names":["formatAPIObjectInput","obj","apiType","undefined","Array","isArray","map","item","Object","keys","reduce","newObj","key","formattedKey","kebabCase","snakeCase","transformsBlacklist","chat","read","matchBlacklist","context","apiName","method","parentLength","parent","length","matcher","mismatch","matcherIndex","desiredValue","entries","buildContext","copiedContext","slice","push","formatAPIObjectOutput","i","camelCase","keybaseExec","workingDir","homeDir","args","options","stdinBuffer","onStdOut","timeout","runArgs","unshift","keybasePath","path","join","child","spawn","stdOutBuffer","stdErrBuffer","stdin","write","end","lineReaderStdout","readline","createInterface","input","stdout","on","chunk","stderr","done","setTimeout","kill","Promise","resolve","reject","code","finalStdOut","errorMessage","Buffer","concat","toString","Error","json","JSON","parse","e","randomTempDir","name","crypto","randomBytes","os","tmpdir","rmdirRecursive","dirName","fsLstat","promisify","fs","lstat","fsUnlink","unlink","fsRmdir","rmdir","fsReaddir","readdir","dirStat","entry","entryPath","stat","isDirectory","keybaseStatus","status","Username","Device","username","devicename","pingKeybaseService","err","aExec","exec","whichKeybase","trim","res","time","Service","constructor","initialized","verbose","botLite","disableTyping","autoLogSendOnCrash","init","paperkey","stringify","serviceLogFile","Boolean","startupService","currentInfo","_paperkey","_killCustomService","initFromRunningService","running","deinit","myInfo","env","process","logSend","initiallyRunning","feedback","API_VERSIONS","team","wallet","ClientBase","_workingDir","spawnedProcesses","_init","initBotInfo","_deinit","_runApiCommand","arg","params","version","inputString","size","output","alloc","hasOwnProperty","error","message","result","_guardInitialized","_pathToKeybaseBinary","Chat","list","conversations","listChannels","optionsWithDefaults","membersType","channel","peek","unreadOnly","pagination","messages","msg","joinChannel","leaveChannel","send","id","createChannel","attach","filename","download","messageId","react","reaction","body","delete","getUnfurlSettings","setUnfurlSettings","mode","loadFlip","conversationID","flipConversationID","messageID","gameID","watchChannelForNewMessages","onMessage","onError","_chatListen","watchAllChannelsForNewMessages","hideExploding","onLine","line","messageObject","sender","toLowerCase","deviceName","Wallet","balances","history","accountId","cleanedRes","payment","details","transactionId","txid","lookup","recipient","amount","currency","batch","batchId","payments","cancel","Team","addMembers","additions","removeMember","removal","listTeamMemberships","Bot","_service","ChatClient","WalletClient","TeamClient","_prepWorkingDir","_initSubBots","keybaseBinaryLocation","destination","mkdirp","copyFile","info"],"mappings":"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"}