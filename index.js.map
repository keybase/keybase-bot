{"version":3,"file":"index.js","sources":["lib/utils.js","lib/store/actions.js","lib/store/reducer.js","lib/store/utils.js","lib/store/index.js","lib/base/index.js","lib/constants.js","lib/chat/index.js","lib/bot.js"],"sourcesContent":["// @flow\nimport snakeCase from 'lodash.snakecase'\nimport {spawn} from 'child_process'\nimport readline from 'readline'\n\ntype ExecOptions = {|\n  stdinBuffer?: Buffer | string,\n  onStdOut?: (line: string) => void,\n  json?: boolean,\n|}\n\nexport function keybaseExec(\n  args: string[],\n  options: ExecOptions = {stdinBuffer: undefined, onStdOut: undefined}\n): Promise<any> {\n  const child = spawn('keybase', args)\n  const outBuffers: Buffer[] = []\n  let out: ?string = null\n\n  if (options.stdinBuffer) {\n    child.stdin.write(options.stdinBuffer)\n  }\n  child.stdin.end()\n\n  const lineReader = readline.createInterface({input: child.stdout})\n  if (options.onStdOut) {\n    lineReader.on('line', options.onStdOut)\n  } else {\n    child.stdout.on('data', chunk => {\n      outBuffers.push(chunk)\n    })\n  }\n\n  return new Promise((resolve, reject) => {\n    child.on('close', code => {\n      if (code) {\n        reject(new Error(`exited with code ${code}`))\n      } else {\n        const stdout = Buffer.concat(outBuffers).toString('utf8')\n\n        try {\n          out = options.json ? JSON.parse(stdout) : stdout\n        } catch (e) {\n          reject(e)\n        }\n      }\n\n      resolve(out)\n    })\n  })\n}\n\n// Recursively convert from camelCase to snake_case for any options object for keybase chat api\nexport const formatOptions = (options: any): any =>\n  Object.keys(options).reduce((newOptions, key) => {\n    if (typeof options[key] === 'object') {\n      return {\n        ...newOptions,\n        [snakeCase(key)]: formatOptions(options[key]),\n      }\n    }\n    return {\n      ...newOptions,\n      [snakeCase(key)]: options[key],\n    }\n  }, {})\n","// @flow\nimport type {Action} from './types'\n\n/*\n * Actions\n */\ntype Props = {|\n  username: string,\n  devicename: string,\n  flags: {|\n    verbose: boolean,\n  |},\n|}\n\nexport const actionInit = (props: Props): Action => ({\n  type: 'INIT',\n  payload: props,\n})\n\nexport const actionDeinit = (): Action => ({\n  type: 'DEINIT',\n  payload: {},\n})\n","// @flow\nimport type {Reducer} from './types'\n\nexport const reducer: Reducer = (state, action) => {\n  switch (action.type) {\n    case 'INIT': {\n      return {\n        ...state,\n        initialized: true,\n        username: action.payload.username,\n        devicename: action.payload.devicename,\n        flags: action.payload.flags,\n      }\n    }\n    case 'DEINIT': {\n      return {\n        ...state,\n        initialized: false,\n        username: undefined,\n        devicename: undefined,\n        flags: {\n          verbose: false,\n        },\n      }\n    }\n    default: {\n      return state\n    }\n  }\n}\n","// @flow\nimport type {AnyApiWithStore} from '../types.js'\nimport type {Store} from './types'\n\n/*\n * withStore is a helper function that can be used to provide a single API function\n * with an insolatd store.\n *\n * This is used in the following situations:\n *  1. Multiple bots are initialized and each one creates its own store\n *  2. Tests where an example store is created, passed in to an API method, and\n *     then discarded\n *\n * Usage:\n *                      A          B\n *  wrappedApiFunc = (store) => (options) => { ... }\n *  guards = [checkInitialized, checkUsernameUnchanged]\n *  apiFunc = withStore(store, guards?)(wrappedApiFun)\n *\n * A is the wrapped function that is provided `store`\n * B is the regular api function that gets closure over `store`\n *\n * This is very useful when initializing new bots and passing in different stores for each Bot\n * as well as testing individual API methods by providing an preconfigured store.\n */\nexport const withStore = (store: Store, allGuards?: AwaitAllGuards) => {\n  return (wrapped: AnyApiWithStore) => {\n    const apiFunc = wrapped(store)\n    // Intentionally allow error to bubble up and be handled by caller\n    const withGuard = async (...args: any) => {\n      if (allGuards) {\n        await allGuards(store)\n      }\n      const res = await apiFunc(...args)\n      return res\n    }\n\n    // If withStore was called using withGuards, then prevent apiFunc from\n    // being called until all guard functions resolve\n    //\n    // Otherwise return the API function directly\n    if (allGuards) {\n      return withGuard\n    }\n    return apiFunc\n  }\n}\n\n/*\n * withGuards takes an array of functions that return Promises. Each function will reject/throw if some condition in the Store does not hold.\n * Example:\n *    withGuards([checkInitialized, checkUsernameUnchanged])\n *\n */\ntype Guard = (store: Store) => Promise<void>\ntype AwaitAllGuards = (store: Store) => Promise<void>\ntype WithGuards = (Array<Guard>) => AwaitAllGuards\nexport const withGuards: WithGuards = guards => async (store: Store) => {\n  for (const guard of guards) {\n    await guard(store)\n  }\n}\n","// @flow\nimport {actionInit, actionDeinit} from './actions'\nimport {reducer} from './reducer'\nimport {withStore, withGuards} from './utils'\nimport type {State, Action, Reducer, Store} from './types'\n\nexport {actionInit, actionDeinit, reducer, withStore, withGuards}\n\n/*\n * Store\n */\nexport const initialState = {\n  initialized: false,\n  username: undefined,\n  devicename: undefined,\n  flags: {\n    verbose: false,\n  },\n}\n\n/*\n * This is basic functional state management (redux-like) without any overhead\n * for middleware or listeners\n *\n * state -> dispatch(action) -> reducer -> new state\n */\nexport const createStore = (reducer: Reducer, init: State = initialState): Store => {\n  let state = init\n  const getState = (): State => ({...state})\n  const dispatch = (action: Action) => {\n    state = reducer(state, action)\n  }\n  return {\n    getState,\n    dispatch,\n  }\n}\n","// @flow\nimport {keybaseExec} from '../utils'\nimport {withStore, actionInit} from '../store'\nimport type {Store} from '../store/types'\nimport type {DeviceUsernamePair} from '../types'\nimport type {Init, MyInfo, Deinit} from './types'\n\n/**\n * @ignore\n * getCurrentUsernameAndDevicename returns { username, devicename } from keybase status -j\n */\nconst getCurrentUsernameAndDevicename = async (): Promise<DeviceUsernamePair> => {\n  const status = await keybaseExec(['status', '--json'], {json: true})\n  if (status && status.Username && status.Device && status.Device.name) {\n    return {username: status.Username, devicename: status.Device.name}\n  } else {\n    throw new Error('failed to get username + device name')\n  }\n}\n\n/**\n * @ignore\n * guardInitialized takes the current store and the api function to guard\n * It ensures that the following conditions remain true\n *  1. The bot was initialized before calling the given api function\n *  2. The bot has username and devicename if it has been initialized\n *  2. The current username and devicename have not changed values\n *\n * If any condition is false, an error is thrown\n * Otherwise, return the function (to be executed later)\n *\n */\nexport const guardInitialized = async (store: Store): Promise<void> => {\n  const currentDPair = await getCurrentUsernameAndDevicename()\n  const {initialized, username, devicename} = store.getState()\n  if (\n    !initialized ||\n    !currentDPair ||\n    !username ||\n    !devicename ||\n    currentDPair.username !== username ||\n    currentDPair.devicename !== devicename\n  ) {\n    throw new Error('Uh-oh, username has changed or we never initialized correctly.')\n  }\n}\n\n/**\n * @namespace bot\n */\n\nexport const _init = (store: Store) => {\n  /**\n   *\n   * `bot.init()` must be run to initialize the bot before using other methods. It\n   * checks to make sure you're properly logged into Keybase and gets basic\n   * info about your session. Afterwards, feel free to check bot.myInfo() to\n   * see or check who you're logged in as.\n   *\n   * @memberof bot\n   *\n   */\n  const init: Init = async (username, paperkey, options) => {\n    if (!username || typeof username !== 'string')\n      throw new Error(`Please provide a username to initialize the bot. Got: ${JSON.stringify(username)}`)\n    // Don't want to accidentally print the paperkey to STDERR\n    if (!paperkey || typeof paperkey !== 'string')\n      throw new Error(`Please provide a paperkey to initialize the bot.`)\n\n    await keybaseExec(['oneshot', '--username', username], {stdinBuffer: paperkey})\n\n    const currentDPair = await getCurrentUsernameAndDevicename()\n    if (currentDPair && currentDPair.username && currentDPair.devicename) {\n      const update = {\n        username: currentDPair.username,\n        devicename: currentDPair.devicename,\n        flags: {\n          verbose: options ? Boolean(options.verbose) : false,\n        },\n      }\n      store.dispatch(actionInit(update))\n      // TODO: @jacob - refactor logging to depend on verbose flag in state\n      // this._log(`intialized ${currentDPair.username} (device=${currentDPair.devicename})`)\n    }\n  }\n  return init\n}\n\n/**\n *\n * Deinitializes a bot by logging it out of its current Keybase session.\n * Should be run after your bot finishes.\n *\n * @memberof bot\n *\n */\nexport const deinit = async (): Promise<void> => {\n  await keybaseExec(['logout'])\n}\n\nexport const _myInfo = (store: Store) => {\n  /**\n   * @memberof bot\n   */\n  const myInfo = (): ?DeviceUsernamePair => {\n    const {username, devicename} = store.getState()\n    if (username && devicename) return {username, devicename}\n    return null\n  }\n  return myInfo\n}\n\nexport default (store: Store) => ({\n  init: withStore(store)(_init),\n  deinit: withStore(store)(store => deinit),\n  myInfo: withStore(store)(_myInfo),\n})\n","// @flow\nconst CHAT_API_VERSION = 1\n\nexport {CHAT_API_VERSION}\n","// @flow\nimport {guardInitialized} from '../base'\nimport {formatOptions, keybaseExec} from '../utils'\nimport {CHAT_API_VERSION} from '../constants'\nimport {withStore, withGuards} from '../store'\nimport type {Store} from '../store/types'\nimport type {ApiCommandArg} from '../types'\nimport type {\n  List,\n  Read,\n  Send,\n  Delete,\n  WatchChannelForNewMessage,\n  WatchAllChannelsForNewMessages,\n  ChatListOptionals,\n  ChatSendOptionals,\n  ChatReadOptionals,\n  ChatDeleteOptionals,\n  ChatConversation,\n  ChatChannel,\n} from './types'\n\nconst runApiCommand = async (arg: ApiCommandArg): Promise<any> => {\n  const options = formatOptions(arg.options)\n  const input = {\n    method: arg.method,\n    params: {\n      version: CHAT_API_VERSION,\n      options,\n    },\n  }\n  const inputString = JSON.stringify(input)\n  const size = inputString.length\n  const output = await keybaseExec(['chat', 'api'], {\n    stdinBuffer: Buffer.alloc(size, inputString, 'utf8'),\n    json: true,\n  })\n  const res = output.result\n  return res\n}\n\n/**\n * Keybase chat api functions\n *\n * @namespace chat\n * @memberof bot\n */\n\n/**\n * Lists your chats, with info on which ones have unread messages.\n *\n * @memberof bot.chat\n *\n */\nexport const list: List = async options => {\n  const res = await runApiCommand({method: 'list', options})\n  return res ? res.conversations || [] : []\n}\n\n/**\n * Reads the messages in a channel. You can read with or without marking as read.\n *\n * @memberof bot.chat\n */\nexport const read: Read = async (channel, options) => {\n  const optionsWithDefaults = {\n    ...options,\n    channel,\n    peek: options.peek !== undefined ? options.peek : false,\n    unreadOnly: options.unreadOnly !== undefined ? options.unreadOnly : false,\n  }\n  await runApiCommand({method: 'read', options: optionsWithDefaults})\n}\n\n/**\n * Sends a message to a certain channel.\n *\n * @memberof bot.chat\n */\nexport const send: Send = async (channel, message, options) => {\n  const args = {\n    ...options,\n    channel,\n    message,\n  }\n  const res = await runApiCommand({method: 'send', options: args})\n  if (!res) {\n    throw new Error('keybase chat send returned nothing')\n  }\n  if (res.hasOwnProperty('error')) {\n    throw new Error(res.error.message)\n  }\n  return res\n}\n\n/**\n * Deletes a message in a channel. Messages have messageId's associated with\n * them, which you can learn in `bot.chatRead`. Known bug: the GUI has a cache,\n * and deleting from the CLI may not become apparent immediately.\n *\n * @alias delete\n * @memberof bot.chat\n */\n\n// delete is a javascript reserved word and cannot be used as a function signature\nexport const deleteMessage: Delete = async (channel, messageId, options) => {\n  const args = {\n    ...options,\n    channel,\n    messageId,\n  }\n  await runApiCommand({method: 'delete', options: args})\n}\n\n/**\n * Listens for new chat messages on a specified channel. The `onMessage` function is called for every message your bot receives.\n * This is pretty similar to `watchAllChannelsForNewMessages`, except it specifically checks one channel.\n *\n * @memberof bot.chat\n */\nexport const watchChannelForNewMessages: WatchChannelForNewMessage = (channel, onMessage) => {\n  keybaseExec(['chat', 'api-listen'], {\n    onStdOut: line => {\n      try {\n        const messageObject = JSON.parse(line)\n        if (channel.name === messageObject.msg.channel.name) {\n          onMessage(messageObject.msg)\n        }\n      } catch (error) {\n        console.error(error)\n      }\n    },\n  })\n}\n\n/**\n *\n * This function will put your bot into insane mode, where it reads\n * everything it can and every new message it finds it will pass to you, so\n * you can do what you want with it. For example, if you want to write a\n * Keybase bot that talks shit at anyone who dares approach it, this is the\n * function to use.*\n *\n * Specifically, it will call the `onMessage` function you provide for every\n * message your bot receives.*\n *\n * @memberof bot.chat\n * @example\n * // reply to incoming traffic on all channels with 'thanks!'\n * var onMessages = function(m) {\n *   var channel = m.channel\n *   var messages = m.messages // we could look in this array to read them and write custom replies\n *   bot.chatSend(\n *     {\n *       channel: channel,\n *       message: {\n *         body: 'thanks!!!',\n *       },\n *     },\n *     function(err, res) {\n *       if (err) {\n *         console.log(err)\n *       }\n *     }\n *   )\n * }\n * bot.watchAllChannelsForNewMessages({onMessages: onMessages})\n *\n */\nexport const watchAllChannelsForNewMessages: WatchAllChannelsForNewMessages = onMessage => {\n  keybaseExec(['chat', 'api-listen'], {\n    onStdOut: (line: string) => {\n      console.log(line)\n      try {\n        const messageObject = JSON.parse(line)\n        onMessage(messageObject.msg)\n      } catch (error) {\n        console.error(error)\n      }\n    },\n  })\n}\n\n// Provide API functions with access to the bot's store using withStore\n// Also provide guard functions to check before executing the API function\nexport default (store: Store) => ({\n  list: withStore(store, withGuards([guardInitialized]))(store => list),\n  read: withStore(store, withGuards([guardInitialized]))(store => read),\n  send: withStore(store, withGuards([guardInitialized]))(store => send),\n  delete: withStore(store, withGuards([guardInitialized]))(store => deleteMessage),\n  watchChannelForNewMessages: withStore(store)(store => watchChannelForNewMessages),\n  watchAllChannelsForNewMessages: withStore(store)(store => watchAllChannelsForNewMessages),\n})\n","// @flow\nimport Base from './base'\nimport Chat from './chat'\nimport {createStore, reducer, initialState} from './store'\nimport type {Store} from './store/types'\n\nclass Bot {\n  store: Store\n  init: any\n  deinit: any\n  myInfo: any\n  chat: any\n\n  constructor() {\n    const _store = createStore(reducer, initialState)\n    const base = Base(_store)\n    const chat = Chat(_store)\n    this.init = base.init\n    this.deinit = base.deinit\n    this.myInfo = base.myInfo\n    this.chat = chat\n  }\n}\n\nexport default Bot\n"],"names":["keybaseExec","args","options","stdinBuffer","undefined","onStdOut","child","spawn","outBuffers","out","stdin","write","end","lineReader","readline","createInterface","input","stdout","on","chunk","push","Promise","resolve","reject","code","Error","Buffer","concat","toString","json","JSON","parse","e","formatOptions","Object","keys","reduce","newOptions","key","snakeCase","actionInit","props","type","payload","reducer","state","action","initialized","username","devicename","flags","verbose","withStore","store","allGuards","wrapped","apiFunc","withGuard","res","withGuards","guards","guard","initialState","createStore","init","getState","dispatch","getCurrentUsernameAndDevicename","status","Username","Device","name","guardInitialized","currentDPair","_init","paperkey","stringify","update","Boolean","deinit","_myInfo","myInfo","CHAT_API_VERSION","runApiCommand","arg","method","params","version","inputString","size","length","output","alloc","result","list","conversations","read","channel","optionsWithDefaults","peek","unreadOnly","send","message","hasOwnProperty","error","deleteMessage","messageId","watchChannelForNewMessages","onMessage","line","messageObject","msg","console","watchAllChannelsForNewMessages","log","delete","Bot","constructor","_store","base","Base","chat","Chat"],"mappings":"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"}